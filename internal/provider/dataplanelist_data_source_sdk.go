// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *DataplaneListDataSourceModel) ToOperationsGetDataplaneListRequest(ctx context.Context) (*operations.GetDataplaneListRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	offset := new(int64)
	if !r.Offset.IsUnknown() && !r.Offset.IsNull() {
		*offset = r.Offset.ValueInt64()
	} else {
		offset = nil
	}
	size := new(int64)
	if !r.Size.IsUnknown() && !r.Size.IsNull() {
		*size = r.Size.ValueInt64()
	} else {
		size = nil
	}
	var mesh string
	mesh = r.Mesh.ValueString()

	out := operations.GetDataplaneListRequest{
		Offset: offset,
		Size:   size,
		Mesh:   mesh,
	}

	return &out, diags
}

func (r *DataplaneListDataSourceModel) RefreshFromSharedDataplaneList(ctx context.Context, resp *shared.DataplaneList) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Items = []tfTypes.DataplaneItem{}
		if len(r.Items) > len(resp.Items) {
			r.Items = r.Items[:len(resp.Items)]
		}
		for itemsCount, itemsItem := range resp.Items {
			var items tfTypes.DataplaneItem
			if len(itemsItem.Labels) > 0 {
				items.Labels = make(map[string]types.String, len(itemsItem.Labels))
				for key, value := range itemsItem.Labels {
					items.Labels[key] = types.StringValue(value)
				}
			}
			items.Mesh = types.StringValue(itemsItem.Mesh)
			if itemsItem.Metrics == nil {
				items.Metrics = nil
			} else {
				items.Metrics = &tfTypes.Metrics{}
				if itemsItem.Metrics.Conf != nil {
					items.Metrics.Conf = &tfTypes.DataplaneItemConf{}
					if itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig != nil {
						items.Metrics.Conf.PrometheusMetricsBackendConfig = &tfTypes.PrometheusMetricsBackendConfig{}
						items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = []tfTypes.Aggregate{}
						for aggregateCount, aggregateItem := range itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate {
							var aggregate tfTypes.Aggregate
							aggregate.Address = types.StringPointerValue(aggregateItem.Address)
							aggregate.Enabled = types.BoolPointerValue(aggregateItem.Enabled)
							aggregate.Name = types.StringPointerValue(aggregateItem.Name)
							aggregate.Path = types.StringPointerValue(aggregateItem.Path)
							aggregate.Port = types.Int64PointerValue(aggregateItem.Port)
							if aggregateCount+1 > len(items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) {
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = append(items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate, aggregate)
							} else {
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Address = aggregate.Address
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Enabled = aggregate.Enabled
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Name = aggregate.Name
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Path = aggregate.Path
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Port = aggregate.Port
							}
						}
						if itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy == nil {
							items.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy = nil
						} else {
							items.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy = &tfTypes.ConfEnvoy{}
							items.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex = types.StringPointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex)
							items.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly = types.BoolPointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly)
						}
						items.Metrics.Conf.PrometheusMetricsBackendConfig.Path = types.StringPointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Path)
						items.Metrics.Conf.PrometheusMetricsBackendConfig.Port = types.Int64PointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Port)
						items.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS = types.BoolPointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS)
						if len(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Tags) > 0 {
							items.Metrics.Conf.PrometheusMetricsBackendConfig.Tags = make(map[string]types.String, len(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Tags))
							for key1, value1 := range itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.Tags {
								items.Metrics.Conf.PrometheusMetricsBackendConfig.Tags[key1] = types.StringValue(value1)
							}
						}
						if itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.TLS == nil {
							items.Metrics.Conf.PrometheusMetricsBackendConfig.TLS = nil
						} else {
							items.Metrics.Conf.PrometheusMetricsBackendConfig.TLS = &tfTypes.ConfTLS{}
							if itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode != nil {
								items.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode = &tfTypes.ConfMode{}
								if itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str != nil {
									items.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str = types.StringPointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str)
								}
								if itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer != nil {
									items.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer = types.Int64PointerValue(itemsItem.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer)
								}
							}
						}
					}
				}
				items.Metrics.Name = types.StringPointerValue(itemsItem.Metrics.Name)
				items.Metrics.Type = types.StringPointerValue(itemsItem.Metrics.Type)
			}
			items.Name = types.StringValue(itemsItem.Name)
			if itemsItem.Networking == nil {
				items.Networking = nil
			} else {
				items.Networking = &tfTypes.Networking{}
				items.Networking.Address = types.StringPointerValue(itemsItem.Networking.Address)
				if itemsItem.Networking.Admin == nil {
					items.Networking.Admin = nil
				} else {
					items.Networking.Admin = &tfTypes.Admin{}
					items.Networking.Admin.Port = types.Int64PointerValue(itemsItem.Networking.Admin.Port)
				}
				items.Networking.AdvertisedAddress = types.StringPointerValue(itemsItem.Networking.AdvertisedAddress)
				if itemsItem.Networking.Gateway == nil {
					items.Networking.Gateway = nil
				} else {
					items.Networking.Gateway = &tfTypes.Gateway{}
					if len(itemsItem.Networking.Gateway.Tags) > 0 {
						items.Networking.Gateway.Tags = make(map[string]types.String, len(itemsItem.Networking.Gateway.Tags))
						for key2, value2 := range itemsItem.Networking.Gateway.Tags {
							items.Networking.Gateway.Tags[key2] = types.StringValue(value2)
						}
					}
					if itemsItem.Networking.Gateway.Type != nil {
						items.Networking.Gateway.Type = &tfTypes.ConfMode{}
						if itemsItem.Networking.Gateway.Type.Str != nil {
							items.Networking.Gateway.Type.Str = types.StringPointerValue(itemsItem.Networking.Gateway.Type.Str)
						}
						if itemsItem.Networking.Gateway.Type.Integer != nil {
							items.Networking.Gateway.Type.Integer = types.Int64PointerValue(itemsItem.Networking.Gateway.Type.Integer)
						}
					}
				}
				items.Networking.Inbound = []tfTypes.DataplaneItemInbound{}
				for inboundCount, inboundItem := range itemsItem.Networking.Inbound {
					var inbound tfTypes.DataplaneItemInbound
					inbound.Address = types.StringPointerValue(inboundItem.Address)
					if inboundItem.Health == nil {
						inbound.Health = nil
					} else {
						inbound.Health = &tfTypes.Health{}
						inbound.Health.Ready = types.BoolPointerValue(inboundItem.Health.Ready)
					}
					inbound.Name = types.StringPointerValue(inboundItem.Name)
					inbound.Port = types.Int64PointerValue(inboundItem.Port)
					inbound.ServiceAddress = types.StringPointerValue(inboundItem.ServiceAddress)
					inbound.ServicePort = types.Int64PointerValue(inboundItem.ServicePort)
					if inboundItem.ServiceProbe == nil {
						inbound.ServiceProbe = nil
					} else {
						inbound.ServiceProbe = &tfTypes.ServiceProbe{}
						inbound.ServiceProbe.HealthyThreshold = types.Int64PointerValue(inboundItem.ServiceProbe.HealthyThreshold)
						if inboundItem.ServiceProbe.Interval == nil {
							inbound.ServiceProbe.Interval = nil
						} else {
							inbound.ServiceProbe.Interval = &tfTypes.Interval{}
							inbound.ServiceProbe.Interval.Nanos = types.Int64PointerValue(inboundItem.ServiceProbe.Interval.Nanos)
							inbound.ServiceProbe.Interval.Seconds = types.Int64PointerValue(inboundItem.ServiceProbe.Interval.Seconds)
						}
						if inboundItem.ServiceProbe.TCP == nil {
							inbound.ServiceProbe.TCP = nil
						} else {
							inbound.ServiceProbe.TCP = &tfTypes.DataplaneItemTCP{}
						}
						if inboundItem.ServiceProbe.Timeout == nil {
							inbound.ServiceProbe.Timeout = nil
						} else {
							inbound.ServiceProbe.Timeout = &tfTypes.Interval{}
							inbound.ServiceProbe.Timeout.Nanos = types.Int64PointerValue(inboundItem.ServiceProbe.Timeout.Nanos)
							inbound.ServiceProbe.Timeout.Seconds = types.Int64PointerValue(inboundItem.ServiceProbe.Timeout.Seconds)
						}
						inbound.ServiceProbe.UnhealthyThreshold = types.Int64PointerValue(inboundItem.ServiceProbe.UnhealthyThreshold)
					}
					if inboundItem.State != nil {
						inbound.State = &tfTypes.ConfMode{}
						if inboundItem.State.Str != nil {
							inbound.State.Str = types.StringPointerValue(inboundItem.State.Str)
						}
						if inboundItem.State.Integer != nil {
							inbound.State.Integer = types.Int64PointerValue(inboundItem.State.Integer)
						}
					}
					if len(inboundItem.Tags) > 0 {
						inbound.Tags = make(map[string]types.String, len(inboundItem.Tags))
						for key3, value3 := range inboundItem.Tags {
							inbound.Tags[key3] = types.StringValue(value3)
						}
					}
					if inboundCount+1 > len(items.Networking.Inbound) {
						items.Networking.Inbound = append(items.Networking.Inbound, inbound)
					} else {
						items.Networking.Inbound[inboundCount].Address = inbound.Address
						items.Networking.Inbound[inboundCount].Health = inbound.Health
						items.Networking.Inbound[inboundCount].Name = inbound.Name
						items.Networking.Inbound[inboundCount].Port = inbound.Port
						items.Networking.Inbound[inboundCount].ServiceAddress = inbound.ServiceAddress
						items.Networking.Inbound[inboundCount].ServicePort = inbound.ServicePort
						items.Networking.Inbound[inboundCount].ServiceProbe = inbound.ServiceProbe
						items.Networking.Inbound[inboundCount].State = inbound.State
						items.Networking.Inbound[inboundCount].Tags = inbound.Tags
					}
				}
				items.Networking.Outbound = []tfTypes.Outbound{}
				for outboundCount, outboundItem := range itemsItem.Networking.Outbound {
					var outbound tfTypes.Outbound
					outbound.Address = types.StringPointerValue(outboundItem.Address)
					if outboundItem.BackendRef == nil {
						outbound.BackendRef = nil
					} else {
						outbound.BackendRef = &tfTypes.BackendRef{}
						outbound.BackendRef.Kind = types.StringPointerValue(outboundItem.BackendRef.Kind)
						if len(outboundItem.BackendRef.Labels) > 0 {
							outbound.BackendRef.Labels = make(map[string]types.String, len(outboundItem.BackendRef.Labels))
							for key4, value4 := range outboundItem.BackendRef.Labels {
								outbound.BackendRef.Labels[key4] = types.StringValue(value4)
							}
						}
						outbound.BackendRef.Name = types.StringPointerValue(outboundItem.BackendRef.Name)
						outbound.BackendRef.Port = types.Int64PointerValue(outboundItem.BackendRef.Port)
					}
					outbound.Port = types.Int64PointerValue(outboundItem.Port)
					if len(outboundItem.Tags) > 0 {
						outbound.Tags = make(map[string]types.String, len(outboundItem.Tags))
						for key5, value5 := range outboundItem.Tags {
							outbound.Tags[key5] = types.StringValue(value5)
						}
					}
					if outboundCount+1 > len(items.Networking.Outbound) {
						items.Networking.Outbound = append(items.Networking.Outbound, outbound)
					} else {
						items.Networking.Outbound[outboundCount].Address = outbound.Address
						items.Networking.Outbound[outboundCount].BackendRef = outbound.BackendRef
						items.Networking.Outbound[outboundCount].Port = outbound.Port
						items.Networking.Outbound[outboundCount].Tags = outbound.Tags
					}
				}
				if itemsItem.Networking.TransparentProxying == nil {
					items.Networking.TransparentProxying = nil
				} else {
					items.Networking.TransparentProxying = &tfTypes.TransparentProxying{}
					items.Networking.TransparentProxying.DirectAccessServices = make([]types.String, 0, len(itemsItem.Networking.TransparentProxying.DirectAccessServices))
					for _, v := range itemsItem.Networking.TransparentProxying.DirectAccessServices {
						items.Networking.TransparentProxying.DirectAccessServices = append(items.Networking.TransparentProxying.DirectAccessServices, types.StringValue(v))
					}
					if itemsItem.Networking.TransparentProxying.IPFamilyMode != nil {
						items.Networking.TransparentProxying.IPFamilyMode = &tfTypes.ConfMode{}
						if itemsItem.Networking.TransparentProxying.IPFamilyMode.Str != nil {
							items.Networking.TransparentProxying.IPFamilyMode.Str = types.StringPointerValue(itemsItem.Networking.TransparentProxying.IPFamilyMode.Str)
						}
						if itemsItem.Networking.TransparentProxying.IPFamilyMode.Integer != nil {
							items.Networking.TransparentProxying.IPFamilyMode.Integer = types.Int64PointerValue(itemsItem.Networking.TransparentProxying.IPFamilyMode.Integer)
						}
					}
					if itemsItem.Networking.TransparentProxying.ReachableBackends == nil {
						items.Networking.TransparentProxying.ReachableBackends = nil
					} else {
						items.Networking.TransparentProxying.ReachableBackends = &tfTypes.ReachableBackends{}
						items.Networking.TransparentProxying.ReachableBackends.Refs = []tfTypes.Refs{}
						for refsCount, refsItem := range itemsItem.Networking.TransparentProxying.ReachableBackends.Refs {
							var refs tfTypes.Refs
							refs.Kind = types.StringPointerValue(refsItem.Kind)
							if len(refsItem.Labels) > 0 {
								refs.Labels = make(map[string]types.String, len(refsItem.Labels))
								for key6, value6 := range refsItem.Labels {
									refs.Labels[key6] = types.StringValue(value6)
								}
							}
							refs.Name = types.StringPointerValue(refsItem.Name)
							refs.Namespace = types.StringPointerValue(refsItem.Namespace)
							refs.Port = types.Int64PointerValue(refsItem.Port)
							if refsCount+1 > len(items.Networking.TransparentProxying.ReachableBackends.Refs) {
								items.Networking.TransparentProxying.ReachableBackends.Refs = append(items.Networking.TransparentProxying.ReachableBackends.Refs, refs)
							} else {
								items.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Kind = refs.Kind
								items.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Labels = refs.Labels
								items.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Name = refs.Name
								items.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Namespace = refs.Namespace
								items.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Port = refs.Port
							}
						}
					}
					items.Networking.TransparentProxying.ReachableServices = make([]types.String, 0, len(itemsItem.Networking.TransparentProxying.ReachableServices))
					for _, v := range itemsItem.Networking.TransparentProxying.ReachableServices {
						items.Networking.TransparentProxying.ReachableServices = append(items.Networking.TransparentProxying.ReachableServices, types.StringValue(v))
					}
					items.Networking.TransparentProxying.RedirectPortInbound = types.Int64PointerValue(itemsItem.Networking.TransparentProxying.RedirectPortInbound)
					items.Networking.TransparentProxying.RedirectPortOutbound = types.Int64PointerValue(itemsItem.Networking.TransparentProxying.RedirectPortOutbound)
				}
			}
			if itemsItem.Probes == nil {
				items.Probes = nil
			} else {
				items.Probes = &tfTypes.Probes{}
				items.Probes.Endpoints = []tfTypes.Endpoints{}
				for endpointsCount, endpointsItem := range itemsItem.Probes.Endpoints {
					var endpoints tfTypes.Endpoints
					endpoints.InboundPath = types.StringPointerValue(endpointsItem.InboundPath)
					endpoints.InboundPort = types.Int64PointerValue(endpointsItem.InboundPort)
					endpoints.Path = types.StringPointerValue(endpointsItem.Path)
					if endpointsCount+1 > len(items.Probes.Endpoints) {
						items.Probes.Endpoints = append(items.Probes.Endpoints, endpoints)
					} else {
						items.Probes.Endpoints[endpointsCount].InboundPath = endpoints.InboundPath
						items.Probes.Endpoints[endpointsCount].InboundPort = endpoints.InboundPort
						items.Probes.Endpoints[endpointsCount].Path = endpoints.Path
					}
				}
				items.Probes.Port = types.Int64PointerValue(itemsItem.Probes.Port)
			}
			items.Type = types.StringValue(itemsItem.Type)
			if itemsCount+1 > len(r.Items) {
				r.Items = append(r.Items, items)
			} else {
				r.Items[itemsCount].Labels = items.Labels
				r.Items[itemsCount].Mesh = items.Mesh
				r.Items[itemsCount].Metrics = items.Metrics
				r.Items[itemsCount].Name = items.Name
				r.Items[itemsCount].Networking = items.Networking
				r.Items[itemsCount].Probes = items.Probes
				r.Items[itemsCount].Type = items.Type
			}
		}
		r.Next = types.StringPointerValue(resp.Next)
		r.Total = types.Float64PointerValue(resp.Total)
	}

	return diags
}
