// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	custom_listplanmodifier "github.com/kong/terraform-provider-kong-mesh/internal/planmodifiers/listplanmodifier"
	custom_objectplanmodifier "github.com/kong/terraform-provider-kong-mesh/internal/planmodifiers/objectplanmodifier"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk"
	speakeasy_objectvalidators "github.com/kong/terraform-provider-kong-mesh/internal/validators/objectvalidators"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &DataplaneResource{}
var _ resource.ResourceWithImportState = &DataplaneResource{}

func NewDataplaneResource() resource.Resource {
	return &DataplaneResource{}
}

// DataplaneResource defines the resource implementation.
type DataplaneResource struct {
	client *sdk.KongMesh
}

// DataplaneResourceModel describes the resource data model.
type DataplaneResourceModel struct {
	Labels     map[string]types.String `tfsdk:"labels"`
	Mesh       types.String            `tfsdk:"mesh"`
	Metrics    *tfTypes.Metrics        `tfsdk:"metrics"`
	Name       types.String            `tfsdk:"name"`
	Networking *tfTypes.Networking     `tfsdk:"networking"`
	Probes     *tfTypes.Probes         `tfsdk:"probes"`
	Type       types.String            `tfsdk:"type"`
	Warnings   []types.String          `tfsdk:"warnings"`
}

func (r *DataplaneResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dataplane"
}

func (r *DataplaneResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "Dataplane Resource",
		Attributes: map[string]schema.Attribute{
			"labels": schema.MapAttribute{
				Optional:    true,
				ElementType: types.StringType,
			},
			"mesh": schema.StringAttribute{
				Required:    true,
				Description: `name of the mesh`,
			},
			"metrics": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"conf": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"prometheus_metrics_backend_config": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"aggregate": schema.ListNestedAttribute{
										Optional: true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"address": schema.StringAttribute{
													Optional:    true,
													Description: `Address on which a service expose HTTP endpoint with Prometheus metrics.`,
												},
												"enabled": schema.BoolAttribute{
													Optional: true,
													MarkdownDescription: `If false then the application won't be scrapped. If nil, then it is treated` + "\n" +
														`as true and kuma-dp scrapes metrics from the service.`,
												},
												"name": schema.StringAttribute{
													Optional:    true,
													Description: `Name which identify given configuration.`,
												},
												"path": schema.StringAttribute{
													Optional:    true,
													Description: `Path on which a service expose HTTP endpoint with Prometheus metrics.`,
												},
												"port": schema.Int64Attribute{
													Optional:    true,
													Description: `Port on which a service expose HTTP endpoint with Prometheus metrics.`,
												},
											},
										},
										MarkdownDescription: `Map with the configuration of applications which metrics are going to be` + "\n" +
											`scrapped by kuma-dp.`,
									},
									"envoy": schema.SingleNestedAttribute{
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"filter_regex": schema.StringAttribute{
												Optional: true,
												MarkdownDescription: `FilterRegex value that is going to be passed to Envoy for filtering` + "\n" +
													`Envoy metrics.`,
											},
											"used_only": schema.BoolAttribute{
												Optional: true,
												MarkdownDescription: `If true then return metrics that Envoy has updated (counters incremented` + "\n" +
													`at least once, gauges changed at least once, and histograms added to at` + "\n" +
													`least once). If nil, then it is treated as false.`,
											},
										},
										Description: `Configuration of Envoy's metrics.`,
									},
									"path": schema.StringAttribute{
										Optional: true,
										MarkdownDescription: `Path on which a dataplane should expose HTTP endpoint with Prometheus` + "\n" +
											`metrics.`,
									},
									"port": schema.Int64Attribute{
										Optional: true,
										MarkdownDescription: `Port on which a dataplane should expose HTTP endpoint with Prometheus` + "\n" +
											`metrics.`,
									},
									"skip_mtls": schema.BoolAttribute{
										Optional: true,
										MarkdownDescription: `If true then endpoints for scraping metrics won't require mTLS even if mTLS` + "\n" +
											`is enabled in Mesh. If nil, then it is treated as false.`,
									},
									"tags": schema.MapAttribute{
										Optional:    true,
										ElementType: types.StringType,
										MarkdownDescription: `Tags associated with an application this dataplane is deployed next to,` + "\n" +
											`e.g. service=web, version=1.0.` + "\n" +
											`` + "`" + `service` + "`" + ` tag is mandatory.`,
									},
									"tls": schema.SingleNestedAttribute{
										Optional: true,
										PlanModifiers: []planmodifier.Object{
											custom_objectplanmodifier.SupressZeroNullModifier(),
										},
										Attributes: map[string]schema.Attribute{
											"mode": schema.SingleNestedAttribute{
												Optional: true,
												Attributes: map[string]schema.Attribute{
													"integer": schema.Int64Attribute{
														Optional: true,
														Validators: []validator.Int64{
															int64validator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("str"),
															}...),
														},
													},
													"str": schema.StringAttribute{
														Optional: true,
														Validators: []validator.String{
															stringvalidator.ConflictsWith(path.Expressions{
																path.MatchRelative().AtParent().AtName("integer"),
															}...),
														},
													},
												},
												MarkdownDescription: `mode defines how configured is the TLS for Prometheus.` + "\n" +
													`Supported values, delegated, disabled, activeMTLSBackend. Default to` + "\n" +
													`` + "`" + `activeMTLSBackend` + "`" + `.`,
											},
										},
										Description: `Configuration of TLS for prometheus listener.`,
									},
								},
							},
						},
					},
					"name": schema.StringAttribute{
						Optional:    true,
						Description: `Name of the backend, can be then used in Mesh.metrics.enabledBackend`,
					},
					"type": schema.StringAttribute{
						Optional:    true,
						Description: `Type of the backend (Kuma ships with 'prometheus')`,
					},
				},
				MarkdownDescription: `Configuration for metrics that should be collected and exposed by the` + "\n" +
					`data plane proxy.` + "\n" +
					`` + "\n" +
					`Settings defined here will override their respective defaults` + "\n" +
					`defined at a Mesh level.`,
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: `name of the Dataplane`,
			},
			"networking": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"address": schema.StringAttribute{
						Optional: true,
						MarkdownDescription: `IP on which the data plane proxy is accessible to the control plane and` + "\n" +
							`other data plane proxies in the same network. This can also be a` + "\n" +
							`hostname, in which case the control plane will periodically resolve it.`,
					},
					"admin": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"port": schema.Int64Attribute{
								Optional:    true,
								Description: `Port on which Envoy Admin API server will be listening`,
							},
						},
						MarkdownDescription: `Admin describes configuration related to Envoy Admin API.` + "\n" +
							`Due to security, all the Envoy Admin endpoints are exposed only on` + "\n" +
							`localhost. Additionally, Envoy will expose ` + "`" + `/ready` + "`" + ` endpoint on` + "\n" +
							`` + "`" + `networking.address` + "`" + ` for health checking systems to be able to check the` + "\n" +
							`state of Envoy. The rest of the endpoints exposed on ` + "`" + `networking.address` + "`" + `` + "\n" +
							`are always protected by mTLS and only meant to be consumed internally by` + "\n" +
							`the control plane.`,
					},
					"advertised_address": schema.StringAttribute{
						Optional: true,
						MarkdownDescription: `In some situations, a data plane proxy resides in a private network (e.g.` + "\n" +
							`Docker) and is not reachable via ` + "`" + `address` + "`" + ` to other data plane proxies.` + "\n" +
							`` + "`" + `advertisedAddress` + "`" + ` is configured with a routable address for such data` + "\n" +
							`plane proxy so that other proxies in the mesh can connect to it over` + "\n" +
							`` + "`" + `advertisedAddress` + "`" + ` and not via address.` + "\n" +
							`` + "\n" +
							`Envoy still binds to the ` + "`" + `address` + "`" + `, not ` + "`" + `advertisedAddress` + "`" + `.`,
					},
					"gateway": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"tags": schema.MapAttribute{
								Optional:    true,
								ElementType: types.StringType,
								MarkdownDescription: `Tags associated with a gateway of this data plane to, e.g.` + "\n" +
									`` + "`" + `kuma.io/service=gateway` + "`" + `, ` + "`" + `env=prod` + "`" + `. ` + "`" + `kuma.io/service` + "`" + ` tag is` + "\n" +
									`mandatory.`,
							},
							"type": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"integer": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("str"),
											}...),
										},
									},
									"str": schema.StringAttribute{
										Optional: true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("integer"),
											}...),
										},
									},
								},
								MarkdownDescription: `Type of gateway this data plane proxy manages.` + "\n" +
									`There are two types: ` + "`" + `DELEGATED` + "`" + ` and ` + "`" + `BUILTIN` + "`" + `. Defaults to` + "\n" +
									`` + "`" + `DELEGATED` + "`" + `.` + "\n" +
									`` + "\n" +
									`A ` + "`" + `DELEGATED` + "`" + ` gateway is an independently deployed proxy (e.g., Kong,` + "\n" +
									`Contour, etc) that receives inbound traffic that is not proxied by` + "\n" +
									`Kuma, and it sends outbound traffic into the data plane proxy.` + "\n" +
									`` + "\n" +
									`The ` + "`" + `BUILTIN` + "`" + ` gateway type causes the data plane proxy itself to be` + "\n" +
									`configured as a gateway.` + "\n" +
									`` + "\n" +
									`See https://kuma.io/docs/latest/explore/gateway/ for more information.`,
							},
						},
						Description: `Gateway describes a configuration of the gateway of the data plane proxy.`,
					},
					"inbound": schema.ListNestedAttribute{
						Optional: true,
						PlanModifiers: []planmodifier.List{
							custom_listplanmodifier.SupressZeroNullModifier(),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							Attributes: map[string]schema.Attribute{
								"address": schema.StringAttribute{
									Optional: true,
									MarkdownDescription: `Address on which inbound listener will be exposed.` + "\n" +
										`Defaults to ` + "`" + `networking.address` + "`" + `.`,
								},
								"health": schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"ready": schema.BoolAttribute{
											Optional: true,
											MarkdownDescription: `Ready indicates if the data plane proxy is ready to serve the` + "\n" +
												`traffic.`,
										},
									},
									MarkdownDescription: `Health describes the status of an inbound.` + "\n" +
										`If 'health' is nil we consider data plane proxy as healthy.` + "\n" +
										`Unhealthy data plane proxies are excluded from Endpoints Discovery` + "\n" +
										`Service (EDS). On Kubernetes, it is filled automatically by the control` + "\n" +
										`plane if Pod has readiness probe configured. On Universal, it can be` + "\n" +
										`set by the external health checking system, but the most common way is` + "\n" +
										`to use service probes.` + "\n" +
										`` + "\n" +
										`See https://kuma.io/docs/latest/documentation/health for more` + "\n" +
										`information.`,
								},
								"name": schema.StringAttribute{
									Optional:    true,
									Description: `Name adds another way of referencing this port, usable with MeshService`,
								},
								"port": schema.Int64Attribute{
									Optional: true,
									MarkdownDescription: `Port of the inbound interface that will forward requests to the` + "\n" +
										`service.` + "\n" +
										`` + "\n" +
										`When transparent proxying is used, it is a port on which the service is` + "\n" +
										`listening to. When transparent proxying is not used, Envoy will bind to` + "\n" +
										`this port.`,
								},
								"service_address": schema.StringAttribute{
									Optional: true,
									MarkdownDescription: `Address of the service that requests will be forwarded to.` + "\n" +
										`Defaults to 'inbound.address', since Kuma DP should be deployed next` + "\n" +
										`to the service.`,
								},
								"service_port": schema.Int64Attribute{
									Optional: true,
									MarkdownDescription: `Port of the service that requests will be forwarded to.` + "\n" +
										`Defaults to the same value as ` + "`" + `port` + "`" + `.`,
								},
								"service_probe": schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"healthy_threshold": schema.Int64Attribute{
											Optional: true,
											MarkdownDescription: `Number of consecutive healthy checks before considering a host` + "\n" +
												`healthy.`,
										},
										"interval": schema.SingleNestedAttribute{
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"nanos": schema.Int64Attribute{
													Optional: true,
												},
												"seconds": schema.Int64Attribute{
													Optional: true,
												},
											},
											Description: `Interval between consecutive health checks.`,
										},
										"tcp": schema.SingleNestedAttribute{
											Optional:    true,
											Description: `Tcp checker tries to establish tcp connection with destination`,
										},
										"timeout": schema.SingleNestedAttribute{
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"nanos": schema.Int64Attribute{
													Optional: true,
												},
												"seconds": schema.Int64Attribute{
													Optional: true,
												},
											},
											Description: `Maximum time to wait for a health check response.`,
										},
										"unhealthy_threshold": schema.Int64Attribute{
											Optional: true,
											MarkdownDescription: `Number of consecutive unhealthy checks before considering a host` + "\n" +
												`unhealthy.`,
										},
									},
									MarkdownDescription: `ServiceProbe defines parameters for probing the service next to` + "\n" +
										`sidecar. When service probe is defined, Envoy will periodically health` + "\n" +
										`check the application next to it and report the status to the control` + "\n" +
										`plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so` + "\n" +
										`this is not used.` + "\n" +
										`` + "\n" +
										`See https://kuma.io/docs/latest/documentation/health for more` + "\n" +
										`information.`,
								},
								"state": schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"integer": schema.Int64Attribute{
											Optional: true,
											Validators: []validator.Int64{
												int64validator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("str"),
												}...),
											},
										},
										"str": schema.StringAttribute{
											Optional: true,
											Validators: []validator.String{
												stringvalidator.ConflictsWith(path.Expressions{
													path.MatchRelative().AtParent().AtName("integer"),
												}...),
											},
										},
									},
									Description: `State describes the current state of the listener.`,
								},
								"tags": schema.MapAttribute{
									Optional:    true,
									ElementType: types.StringType,
									MarkdownDescription: `Tags associated with an application this data plane proxy is deployed` + "\n" +
										`next to, e.g. ` + "`" + `kuma.io/service=web` + "`" + `, ` + "`" + `version=1.0` + "`" + `. You can then` + "\n" +
										`reference these tags in policies like MeshTrafficPermission.` + "\n" +
										`` + "`" + `kuma.io/service` + "`" + ` tag is mandatory.`,
								},
							},
						},
						MarkdownDescription: `Inbound describes a list of inbound interfaces of the data plane proxy.` + "\n" +
							`` + "\n" +
							`Inbound describes a service implemented by the data plane proxy.` + "\n" +
							`All incoming traffic to a data plane proxy is going through inbound` + "\n" +
							`listeners. For every defined Inbound there is a corresponding Envoy` + "\n" +
							`Listener.`,
					},
					"outbound": schema.ListNestedAttribute{
						Optional: true,
						PlanModifiers: []planmodifier.List{
							custom_listplanmodifier.SupressZeroNullModifier(),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							Attributes: map[string]schema.Attribute{
								"address": schema.StringAttribute{
									Optional: true,
									MarkdownDescription: `IP on which the consumed service will be available to this data plane` + "\n" +
										`proxy. On Kubernetes, it's usually ClusterIP of a Service or PodIP of a` + "\n" +
										`Headless Service. Defaults to 127.0.0.1`,
								},
								"backend_ref": schema.SingleNestedAttribute{
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"kind": schema.StringAttribute{
											Optional:    true,
											Description: `Kind is a type of the object to target. Allowed: MeshService`,
										},
										"labels": schema.MapAttribute{
											Optional:    true,
											ElementType: types.StringType,
											MarkdownDescription: `Labels to select a single object.` + "\n" +
												`If no object is selected then outbound is not created.` + "\n" +
												`If multiple objects are selected then the oldest one is used.`,
										},
										"name": schema.StringAttribute{
											Optional:    true,
											Description: `Name of the targeted object`,
										},
										"port": schema.Int64Attribute{
											Optional:    true,
											Description: `Port of the targeted object. Required when kind is MeshService.`,
										},
									},
									MarkdownDescription: `BackendRef is a way to target MeshService.` + "\n" +
										`Experimental. Do not use on production yet.`,
								},
								"port": schema.Int64Attribute{
									Optional: true,
									MarkdownDescription: `Port on which the consumed service will be available to this data plane` + "\n" +
										`proxy. When transparent proxying is not used, Envoy will bind to this` + "\n" +
										`port.`,
								},
								"tags": schema.MapAttribute{
									Optional:    true,
									ElementType: types.StringType,
									MarkdownDescription: `Tags of consumed data plane proxies.` + "\n" +
										`` + "`" + `kuma.io/service` + "`" + ` tag is required.` + "\n" +
										`These tags can then be referenced in ` + "`" + `destinations` + "`" + ` section of policies` + "\n" +
										`like TrafficRoute or in ` + "`" + `to` + "`" + ` section in policies like MeshAccessLog. It` + "\n" +
										`is recommended to only use ` + "`" + `kuma.io/service` + "`" + `. If you need to consume` + "\n" +
										`specific data plane proxy of a service (for example: ` + "`" + `version=v2` + "`" + `) the` + "\n" +
										`better practice is to use TrafficRoute.`,
								},
							},
						},
						MarkdownDescription: `Outbound describes a list of services consumed by the data plane proxy.` + "\n" +
							`For every defined Outbound, there is a corresponding Envoy Listener.`,
					},
					"transparent_proxying": schema.SingleNestedAttribute{
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"direct_access_services": schema.ListAttribute{
								Optional: true,
								PlanModifiers: []planmodifier.List{
									custom_listplanmodifier.SupressZeroNullModifier(),
								},
								ElementType: types.StringType,
								MarkdownDescription: `List of services that will be accessed directly via IP:PORT` + "\n" +
									`Use ` + "`" + `*` + "`" + ` to indicate direct access to every service in the Mesh.` + "\n" +
									`Using ` + "`" + `*` + "`" + ` to directly access every service is a resource-intensive` + "\n" +
									`operation, use it only if needed.`,
							},
							"ip_family_mode": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"integer": schema.Int64Attribute{
										Optional: true,
										Validators: []validator.Int64{
											int64validator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("str"),
											}...),
										},
									},
									"str": schema.StringAttribute{
										Optional: true,
										Validators: []validator.String{
											stringvalidator.ConflictsWith(path.Expressions{
												path.MatchRelative().AtParent().AtName("integer"),
											}...),
										},
									},
								},
								Description: `The IP family mode to enable for. Can be "IPv4" or "DualStack".`,
							},
							"reachable_backends": schema.SingleNestedAttribute{
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"refs": schema.ListNestedAttribute{
										Optional: true,
										PlanModifiers: []planmodifier.List{
											custom_listplanmodifier.SupressZeroNullModifier(),
										},
										NestedObject: schema.NestedAttributeObject{
											Validators: []validator.Object{
												speakeasy_objectvalidators.NotNull(),
											},
											Attributes: map[string]schema.Attribute{
												"kind": schema.StringAttribute{
													Optional: true,
													MarkdownDescription: `Type of the backend: MeshService or MeshExternalService` + "\n" +
														`` + "\n" +
														`	+required`,
												},
												"labels": schema.MapAttribute{
													Optional:    true,
													ElementType: types.StringType,
													MarkdownDescription: `Labels used to select backends` + "\n" +
														`` + "\n" +
														`	+optional`,
												},
												"name": schema.StringAttribute{
													Optional: true,
													MarkdownDescription: `Name of the backend.` + "\n" +
														`` + "\n" +
														`	+optional`,
												},
												"namespace": schema.StringAttribute{
													Optional: true,
													MarkdownDescription: `Namespace of the backend. Might be empty` + "\n" +
														`` + "\n" +
														`	+optional`,
												},
												"port": schema.Int64Attribute{
													Optional: true,
													MarkdownDescription: `Port of the backend.` + "\n" +
														`` + "\n" +
														`	+optional`,
												},
											},
										},
									},
								},
								MarkdownDescription: `Reachable backend via transparent proxy when running with` + "\n" +
									`MeshExternalService, MeshService and MeshMultiZoneService. Setting an` + "\n" +
									`explicit list of refs can dramatically improve the performance of the` + "\n" +
									`mesh. If not specified, all services in the mesh are reachable.`,
							},
							"reachable_services": schema.ListAttribute{
								Optional: true,
								PlanModifiers: []planmodifier.List{
									custom_listplanmodifier.SupressZeroNullModifier(),
								},
								ElementType: types.StringType,
								MarkdownDescription: `List of reachable services (represented by the value of` + "\n" +
									`` + "`" + `kuma.io/service` + "`" + `) via transparent proxying. Setting an explicit list` + "\n" +
									`can dramatically improve the performance of the mesh. If not specified,` + "\n" +
									`all services in the mesh are reachable.`,
							},
							"redirect_port_inbound": schema.Int64Attribute{
								Optional:    true,
								Description: `Port on which all inbound traffic is being transparently redirected.`,
							},
							"redirect_port_outbound": schema.Int64Attribute{
								Optional:    true,
								Description: `Port on which all outbound traffic is being transparently redirected.`,
							},
						},
						MarkdownDescription: `TransparentProxying describes the configuration for transparent proxying.` + "\n" +
							`It is used by default on Kubernetes.`,
					},
				},
				MarkdownDescription: `Networking describes inbound and outbound interfaces of the data plane` + "\n" +
					`proxy.`,
			},
			"probes": schema.SingleNestedAttribute{
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"endpoints": schema.ListNestedAttribute{
						Optional: true,
						PlanModifiers: []planmodifier.List{
							custom_listplanmodifier.SupressZeroNullModifier(),
						},
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							Attributes: map[string]schema.Attribute{
								"inbound_path": schema.StringAttribute{
									Optional: true,
									MarkdownDescription: `Inbound path is a path of the application from which we expose the` + "\n" +
										`endpoint. It is recommended to be as specific as possible.`,
								},
								"inbound_port": schema.Int64Attribute{
									Optional: true,
									MarkdownDescription: `Inbound port is a port of the application from which we expose the` + "\n" +
										`endpoint.`,
								},
								"path": schema.StringAttribute{
									Optional:    true,
									Description: `Path is a path on which we expose inbound path on the probes port.`,
								},
							},
						},
						Description: `List of endpoints to expose without mTLS.`,
					},
					"port": schema.Int64Attribute{
						Optional: true,
						MarkdownDescription: `Port on which the probe endpoints will be exposed. This cannot overlap` + "\n" +
							`with any other ports.`,
					},
				},
				MarkdownDescription: `Probes describe a list of endpoints that will be exposed without mTLS.` + "\n" +
					`This is useful to expose the health endpoints of the application so the` + "\n" +
					`orchestration system (e.g. Kubernetes) can still health check the` + "\n" +
					`application.` + "\n" +
					`` + "\n" +
					`See` + "\n" +
					`https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes` + "\n" +
					`for more information.` + "\n" +
					`Deprecated: this feature will be removed for Universal; on Kubernetes, it's` + "\n" +
					`not needed anymore.`,
			},
			"type": schema.StringAttribute{
				Required: true,
			},
			"warnings": schema.ListAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.List{
					custom_listplanmodifier.SupressZeroNullModifier(),
				},
				ElementType: types.StringType,
				MarkdownDescription: `warnings is a list of warning messages to return to the requesting Kuma API clients.` + "\n" +
					`Warning messages describe a problem the client making the API request should correct or be aware of.`,
			},
		},
	}
}

func (r *DataplaneResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.KongMesh)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.KongMesh, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *DataplaneResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *DataplaneResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsCreateDataplaneRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Dataplane.CreateDataplane(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 201 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.DataplaneCreateOrUpdateSuccessResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedDataplaneCreateOrUpdateSuccessResponse(ctx, res.DataplaneCreateOrUpdateSuccessResponse)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetDataplaneRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Dataplane.GetDataplane(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.DataplaneItem != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedDataplaneItem(ctx, res1.DataplaneItem)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DataplaneResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *DataplaneResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsGetDataplaneRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Dataplane.GetDataplane(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.DataplaneItem != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedDataplaneItem(ctx, res.DataplaneItem)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DataplaneResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *DataplaneResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsUpdateDataplaneRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Dataplane.UpdateDataplane(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.DataplaneCreateOrUpdateSuccessResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedDataplaneCreateOrUpdateSuccessResponse(ctx, res.DataplaneCreateOrUpdateSuccessResponse)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}
	request1, request1Diags := data.ToOperationsGetDataplaneRequest(ctx)
	resp.Diagnostics.Append(request1Diags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res1, err := r.client.Dataplane.GetDataplane(ctx, *request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.DataplaneItem != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	resp.Diagnostics.Append(data.RefreshFromSharedDataplaneItem(ctx, res1.DataplaneItem)...)

	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(refreshPlan(ctx, plan, &data)...)

	if resp.Diagnostics.HasError() {
		return
	}

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *DataplaneResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *DataplaneResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request, requestDiags := data.ToOperationsDeleteDataplaneRequest(ctx)
	resp.Diagnostics.Append(requestDiags...)

	if resp.Diagnostics.HasError() {
		return
	}
	res, err := r.client.Dataplane.DeleteDataplane(ctx, *request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *DataplaneResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	dec := json.NewDecoder(bytes.NewReader([]byte(req.ID)))
	dec.DisallowUnknownFields()
	var data struct {
		Mesh string `json:"mesh"`
		Name string `json:"name"`
	}

	if err := dec.Decode(&data); err != nil {
		resp.Diagnostics.AddError("Invalid ID", `The import ID is not valid. It is expected to be a JSON object string with the format: '{ "mesh": "",  "name": ""}': `+err.Error())
		return
	}

	if len(data.Mesh) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field mesh is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("mesh"), data.Mesh)...)
	if len(data.Name) == 0 {
		resp.Diagnostics.AddError("Missing required field", `The field name is required but was not found in the json encoded ID. It's expected to be a value alike '""`)
		return
	}
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("name"), data.Name)...)

}
