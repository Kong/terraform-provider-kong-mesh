// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *DataplaneResourceModel) ToSharedDataplaneItem(ctx context.Context) (*shared.DataplaneItem, diag.Diagnostics) {
	var diags diag.Diagnostics

	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var mesh string
	mesh = r.Mesh.ValueString()

	var metrics *shared.Metrics
	if r.Metrics != nil {
		var conf *shared.DataplaneItemConf
		if r.Metrics.Conf != nil {
			var prometheusMetricsBackendConfig *shared.PrometheusMetricsBackendConfig
			if r.Metrics.Conf.PrometheusMetricsBackendConfig != nil {
				aggregate := make([]shared.Aggregate, 0, len(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate))
				for _, aggregateItem := range r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate {
					address := new(string)
					if !aggregateItem.Address.IsUnknown() && !aggregateItem.Address.IsNull() {
						*address = aggregateItem.Address.ValueString()
					} else {
						address = nil
					}
					enabled := new(bool)
					if !aggregateItem.Enabled.IsUnknown() && !aggregateItem.Enabled.IsNull() {
						*enabled = aggregateItem.Enabled.ValueBool()
					} else {
						enabled = nil
					}
					name := new(string)
					if !aggregateItem.Name.IsUnknown() && !aggregateItem.Name.IsNull() {
						*name = aggregateItem.Name.ValueString()
					} else {
						name = nil
					}
					path := new(string)
					if !aggregateItem.Path.IsUnknown() && !aggregateItem.Path.IsNull() {
						*path = aggregateItem.Path.ValueString()
					} else {
						path = nil
					}
					port := new(int64)
					if !aggregateItem.Port.IsUnknown() && !aggregateItem.Port.IsNull() {
						*port = aggregateItem.Port.ValueInt64()
					} else {
						port = nil
					}
					aggregate = append(aggregate, shared.Aggregate{
						Address: address,
						Enabled: enabled,
						Name:    name,
						Path:    path,
						Port:    port,
					})
				}
				var envoy *shared.ConfEnvoy
				if r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy != nil {
					filterRegex := new(string)
					if !r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex.IsNull() {
						*filterRegex = r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex.ValueString()
					} else {
						filterRegex = nil
					}
					usedOnly := new(bool)
					if !r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly.IsNull() {
						*usedOnly = r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly.ValueBool()
					} else {
						usedOnly = nil
					}
					envoy = &shared.ConfEnvoy{
						FilterRegex: filterRegex,
						UsedOnly:    usedOnly,
					}
				}
				path1 := new(string)
				if !r.Metrics.Conf.PrometheusMetricsBackendConfig.Path.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.Path.IsNull() {
					*path1 = r.Metrics.Conf.PrometheusMetricsBackendConfig.Path.ValueString()
				} else {
					path1 = nil
				}
				port1 := new(int64)
				if !r.Metrics.Conf.PrometheusMetricsBackendConfig.Port.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.Port.IsNull() {
					*port1 = r.Metrics.Conf.PrometheusMetricsBackendConfig.Port.ValueInt64()
				} else {
					port1 = nil
				}
				skipMTLS := new(bool)
				if !r.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS.IsNull() {
					*skipMTLS = r.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS.ValueBool()
				} else {
					skipMTLS = nil
				}
				tags := make(map[string]string)
				for tagsKey, tagsValue := range r.Metrics.Conf.PrometheusMetricsBackendConfig.Tags {
					var tagsInst string
					tagsInst = tagsValue.ValueString()

					tags[tagsKey] = tagsInst
				}
				var tls *shared.ConfTLS
				if r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS != nil {
					var mode *shared.ConfMode
					if r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode != nil {
						str := new(string)
						if !r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str.IsNull() {
							*str = r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str.ValueString()
						} else {
							str = nil
						}
						if str != nil {
							mode = &shared.ConfMode{
								Str: str,
							}
						}
						integer := new(int64)
						if !r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer.IsUnknown() && !r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer.IsNull() {
							*integer = r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer.ValueInt64()
						} else {
							integer = nil
						}
						if integer != nil {
							mode = &shared.ConfMode{
								Integer: integer,
							}
						}
					}
					tls = &shared.ConfTLS{
						Mode: mode,
					}
				}
				prometheusMetricsBackendConfig = &shared.PrometheusMetricsBackendConfig{
					Aggregate: aggregate,
					Envoy:     envoy,
					Path:      path1,
					Port:      port1,
					SkipMTLS:  skipMTLS,
					Tags:      tags,
					TLS:       tls,
				}
			}
			if prometheusMetricsBackendConfig != nil {
				conf = &shared.DataplaneItemConf{
					PrometheusMetricsBackendConfig: prometheusMetricsBackendConfig,
				}
			}
		}
		name1 := new(string)
		if !r.Metrics.Name.IsUnknown() && !r.Metrics.Name.IsNull() {
			*name1 = r.Metrics.Name.ValueString()
		} else {
			name1 = nil
		}
		typeVar := new(string)
		if !r.Metrics.Type.IsUnknown() && !r.Metrics.Type.IsNull() {
			*typeVar = r.Metrics.Type.ValueString()
		} else {
			typeVar = nil
		}
		metrics = &shared.Metrics{
			Conf: conf,
			Name: name1,
			Type: typeVar,
		}
	}
	var name2 string
	name2 = r.Name.ValueString()

	var networking *shared.Networking
	if r.Networking != nil {
		address1 := new(string)
		if !r.Networking.Address.IsUnknown() && !r.Networking.Address.IsNull() {
			*address1 = r.Networking.Address.ValueString()
		} else {
			address1 = nil
		}
		var admin *shared.Admin
		if r.Networking.Admin != nil {
			port2 := new(int64)
			if !r.Networking.Admin.Port.IsUnknown() && !r.Networking.Admin.Port.IsNull() {
				*port2 = r.Networking.Admin.Port.ValueInt64()
			} else {
				port2 = nil
			}
			admin = &shared.Admin{
				Port: port2,
			}
		}
		advertisedAddress := new(string)
		if !r.Networking.AdvertisedAddress.IsUnknown() && !r.Networking.AdvertisedAddress.IsNull() {
			*advertisedAddress = r.Networking.AdvertisedAddress.ValueString()
		} else {
			advertisedAddress = nil
		}
		var gateway *shared.Gateway
		if r.Networking.Gateway != nil {
			tags1 := make(map[string]string)
			for tagsKey1, tagsValue1 := range r.Networking.Gateway.Tags {
				var tagsInst1 string
				tagsInst1 = tagsValue1.ValueString()

				tags1[tagsKey1] = tagsInst1
			}
			var typeVar1 *shared.DataplaneItemType
			if r.Networking.Gateway.Type != nil {
				str1 := new(string)
				if !r.Networking.Gateway.Type.Str.IsUnknown() && !r.Networking.Gateway.Type.Str.IsNull() {
					*str1 = r.Networking.Gateway.Type.Str.ValueString()
				} else {
					str1 = nil
				}
				if str1 != nil {
					typeVar1 = &shared.DataplaneItemType{
						Str: str1,
					}
				}
				integer1 := new(int64)
				if !r.Networking.Gateway.Type.Integer.IsUnknown() && !r.Networking.Gateway.Type.Integer.IsNull() {
					*integer1 = r.Networking.Gateway.Type.Integer.ValueInt64()
				} else {
					integer1 = nil
				}
				if integer1 != nil {
					typeVar1 = &shared.DataplaneItemType{
						Integer: integer1,
					}
				}
			}
			gateway = &shared.Gateway{
				Tags: tags1,
				Type: typeVar1,
			}
		}
		inbound := make([]shared.DataplaneItemInbound, 0, len(r.Networking.Inbound))
		for _, inboundItem := range r.Networking.Inbound {
			address2 := new(string)
			if !inboundItem.Address.IsUnknown() && !inboundItem.Address.IsNull() {
				*address2 = inboundItem.Address.ValueString()
			} else {
				address2 = nil
			}
			var health *shared.Health
			if inboundItem.Health != nil {
				ready := new(bool)
				if !inboundItem.Health.Ready.IsUnknown() && !inboundItem.Health.Ready.IsNull() {
					*ready = inboundItem.Health.Ready.ValueBool()
				} else {
					ready = nil
				}
				health = &shared.Health{
					Ready: ready,
				}
			}
			name3 := new(string)
			if !inboundItem.Name.IsUnknown() && !inboundItem.Name.IsNull() {
				*name3 = inboundItem.Name.ValueString()
			} else {
				name3 = nil
			}
			port3 := new(int64)
			if !inboundItem.Port.IsUnknown() && !inboundItem.Port.IsNull() {
				*port3 = inboundItem.Port.ValueInt64()
			} else {
				port3 = nil
			}
			serviceAddress := new(string)
			if !inboundItem.ServiceAddress.IsUnknown() && !inboundItem.ServiceAddress.IsNull() {
				*serviceAddress = inboundItem.ServiceAddress.ValueString()
			} else {
				serviceAddress = nil
			}
			servicePort := new(int64)
			if !inboundItem.ServicePort.IsUnknown() && !inboundItem.ServicePort.IsNull() {
				*servicePort = inboundItem.ServicePort.ValueInt64()
			} else {
				servicePort = nil
			}
			var serviceProbe *shared.ServiceProbe
			if inboundItem.ServiceProbe != nil {
				healthyThreshold := new(int64)
				if !inboundItem.ServiceProbe.HealthyThreshold.IsUnknown() && !inboundItem.ServiceProbe.HealthyThreshold.IsNull() {
					*healthyThreshold = inboundItem.ServiceProbe.HealthyThreshold.ValueInt64()
				} else {
					healthyThreshold = nil
				}
				var interval *shared.Interval
				if inboundItem.ServiceProbe.Interval != nil {
					nanos := new(int64)
					if !inboundItem.ServiceProbe.Interval.Nanos.IsUnknown() && !inboundItem.ServiceProbe.Interval.Nanos.IsNull() {
						*nanos = inboundItem.ServiceProbe.Interval.Nanos.ValueInt64()
					} else {
						nanos = nil
					}
					seconds := new(int64)
					if !inboundItem.ServiceProbe.Interval.Seconds.IsUnknown() && !inboundItem.ServiceProbe.Interval.Seconds.IsNull() {
						*seconds = inboundItem.ServiceProbe.Interval.Seconds.ValueInt64()
					} else {
						seconds = nil
					}
					interval = &shared.Interval{
						Nanos:   nanos,
						Seconds: seconds,
					}
				}
				var tcp *shared.DataplaneItemTCP
				if inboundItem.ServiceProbe.TCP != nil {
					tcp = &shared.DataplaneItemTCP{}
				}
				var timeout *shared.Timeout
				if inboundItem.ServiceProbe.Timeout != nil {
					nanos1 := new(int64)
					if !inboundItem.ServiceProbe.Timeout.Nanos.IsUnknown() && !inboundItem.ServiceProbe.Timeout.Nanos.IsNull() {
						*nanos1 = inboundItem.ServiceProbe.Timeout.Nanos.ValueInt64()
					} else {
						nanos1 = nil
					}
					seconds1 := new(int64)
					if !inboundItem.ServiceProbe.Timeout.Seconds.IsUnknown() && !inboundItem.ServiceProbe.Timeout.Seconds.IsNull() {
						*seconds1 = inboundItem.ServiceProbe.Timeout.Seconds.ValueInt64()
					} else {
						seconds1 = nil
					}
					timeout = &shared.Timeout{
						Nanos:   nanos1,
						Seconds: seconds1,
					}
				}
				unhealthyThreshold := new(int64)
				if !inboundItem.ServiceProbe.UnhealthyThreshold.IsUnknown() && !inboundItem.ServiceProbe.UnhealthyThreshold.IsNull() {
					*unhealthyThreshold = inboundItem.ServiceProbe.UnhealthyThreshold.ValueInt64()
				} else {
					unhealthyThreshold = nil
				}
				serviceProbe = &shared.ServiceProbe{
					HealthyThreshold:   healthyThreshold,
					Interval:           interval,
					TCP:                tcp,
					Timeout:            timeout,
					UnhealthyThreshold: unhealthyThreshold,
				}
			}
			var state *shared.DataplaneItemState
			if inboundItem.State != nil {
				str2 := new(string)
				if !inboundItem.State.Str.IsUnknown() && !inboundItem.State.Str.IsNull() {
					*str2 = inboundItem.State.Str.ValueString()
				} else {
					str2 = nil
				}
				if str2 != nil {
					state = &shared.DataplaneItemState{
						Str: str2,
					}
				}
				integer2 := new(int64)
				if !inboundItem.State.Integer.IsUnknown() && !inboundItem.State.Integer.IsNull() {
					*integer2 = inboundItem.State.Integer.ValueInt64()
				} else {
					integer2 = nil
				}
				if integer2 != nil {
					state = &shared.DataplaneItemState{
						Integer: integer2,
					}
				}
			}
			tags2 := make(map[string]string)
			for tagsKey2, tagsValue2 := range inboundItem.Tags {
				var tagsInst2 string
				tagsInst2 = tagsValue2.ValueString()

				tags2[tagsKey2] = tagsInst2
			}
			inbound = append(inbound, shared.DataplaneItemInbound{
				Address:        address2,
				Health:         health,
				Name:           name3,
				Port:           port3,
				ServiceAddress: serviceAddress,
				ServicePort:    servicePort,
				ServiceProbe:   serviceProbe,
				State:          state,
				Tags:           tags2,
			})
		}
		outbound := make([]shared.Outbound, 0, len(r.Networking.Outbound))
		for _, outboundItem := range r.Networking.Outbound {
			address3 := new(string)
			if !outboundItem.Address.IsUnknown() && !outboundItem.Address.IsNull() {
				*address3 = outboundItem.Address.ValueString()
			} else {
				address3 = nil
			}
			var backendRef *shared.BackendRef
			if outboundItem.BackendRef != nil {
				kind := new(string)
				if !outboundItem.BackendRef.Kind.IsUnknown() && !outboundItem.BackendRef.Kind.IsNull() {
					*kind = outboundItem.BackendRef.Kind.ValueString()
				} else {
					kind = nil
				}
				labels1 := make(map[string]string)
				for labelsKey1, labelsValue1 := range outboundItem.BackendRef.Labels {
					var labelsInst1 string
					labelsInst1 = labelsValue1.ValueString()

					labels1[labelsKey1] = labelsInst1
				}
				name4 := new(string)
				if !outboundItem.BackendRef.Name.IsUnknown() && !outboundItem.BackendRef.Name.IsNull() {
					*name4 = outboundItem.BackendRef.Name.ValueString()
				} else {
					name4 = nil
				}
				port4 := new(int64)
				if !outboundItem.BackendRef.Port.IsUnknown() && !outboundItem.BackendRef.Port.IsNull() {
					*port4 = outboundItem.BackendRef.Port.ValueInt64()
				} else {
					port4 = nil
				}
				backendRef = &shared.BackendRef{
					Kind:   kind,
					Labels: labels1,
					Name:   name4,
					Port:   port4,
				}
			}
			port5 := new(int64)
			if !outboundItem.Port.IsUnknown() && !outboundItem.Port.IsNull() {
				*port5 = outboundItem.Port.ValueInt64()
			} else {
				port5 = nil
			}
			tags3 := make(map[string]string)
			for tagsKey3, tagsValue3 := range outboundItem.Tags {
				var tagsInst3 string
				tagsInst3 = tagsValue3.ValueString()

				tags3[tagsKey3] = tagsInst3
			}
			outbound = append(outbound, shared.Outbound{
				Address:    address3,
				BackendRef: backendRef,
				Port:       port5,
				Tags:       tags3,
			})
		}
		var transparentProxying *shared.TransparentProxying
		if r.Networking.TransparentProxying != nil {
			directAccessServices := make([]string, 0, len(r.Networking.TransparentProxying.DirectAccessServices))
			for _, directAccessServicesItem := range r.Networking.TransparentProxying.DirectAccessServices {
				directAccessServices = append(directAccessServices, directAccessServicesItem.ValueString())
			}
			var ipFamilyMode *shared.IPFamilyMode
			if r.Networking.TransparentProxying.IPFamilyMode != nil {
				str3 := new(string)
				if !r.Networking.TransparentProxying.IPFamilyMode.Str.IsUnknown() && !r.Networking.TransparentProxying.IPFamilyMode.Str.IsNull() {
					*str3 = r.Networking.TransparentProxying.IPFamilyMode.Str.ValueString()
				} else {
					str3 = nil
				}
				if str3 != nil {
					ipFamilyMode = &shared.IPFamilyMode{
						Str: str3,
					}
				}
				integer3 := new(int64)
				if !r.Networking.TransparentProxying.IPFamilyMode.Integer.IsUnknown() && !r.Networking.TransparentProxying.IPFamilyMode.Integer.IsNull() {
					*integer3 = r.Networking.TransparentProxying.IPFamilyMode.Integer.ValueInt64()
				} else {
					integer3 = nil
				}
				if integer3 != nil {
					ipFamilyMode = &shared.IPFamilyMode{
						Integer: integer3,
					}
				}
			}
			var reachableBackends *shared.ReachableBackends
			if r.Networking.TransparentProxying.ReachableBackends != nil {
				refs := make([]shared.Refs, 0, len(r.Networking.TransparentProxying.ReachableBackends.Refs))
				for _, refsItem := range r.Networking.TransparentProxying.ReachableBackends.Refs {
					kind1 := new(string)
					if !refsItem.Kind.IsUnknown() && !refsItem.Kind.IsNull() {
						*kind1 = refsItem.Kind.ValueString()
					} else {
						kind1 = nil
					}
					labels2 := make(map[string]string)
					for labelsKey2, labelsValue2 := range refsItem.Labels {
						var labelsInst2 string
						labelsInst2 = labelsValue2.ValueString()

						labels2[labelsKey2] = labelsInst2
					}
					name5 := new(string)
					if !refsItem.Name.IsUnknown() && !refsItem.Name.IsNull() {
						*name5 = refsItem.Name.ValueString()
					} else {
						name5 = nil
					}
					namespace := new(string)
					if !refsItem.Namespace.IsUnknown() && !refsItem.Namespace.IsNull() {
						*namespace = refsItem.Namespace.ValueString()
					} else {
						namespace = nil
					}
					port6 := new(int64)
					if !refsItem.Port.IsUnknown() && !refsItem.Port.IsNull() {
						*port6 = refsItem.Port.ValueInt64()
					} else {
						port6 = nil
					}
					refs = append(refs, shared.Refs{
						Kind:      kind1,
						Labels:    labels2,
						Name:      name5,
						Namespace: namespace,
						Port:      port6,
					})
				}
				reachableBackends = &shared.ReachableBackends{
					Refs: refs,
				}
			}
			reachableServices := make([]string, 0, len(r.Networking.TransparentProxying.ReachableServices))
			for _, reachableServicesItem := range r.Networking.TransparentProxying.ReachableServices {
				reachableServices = append(reachableServices, reachableServicesItem.ValueString())
			}
			redirectPortInbound := new(int64)
			if !r.Networking.TransparentProxying.RedirectPortInbound.IsUnknown() && !r.Networking.TransparentProxying.RedirectPortInbound.IsNull() {
				*redirectPortInbound = r.Networking.TransparentProxying.RedirectPortInbound.ValueInt64()
			} else {
				redirectPortInbound = nil
			}
			redirectPortOutbound := new(int64)
			if !r.Networking.TransparentProxying.RedirectPortOutbound.IsUnknown() && !r.Networking.TransparentProxying.RedirectPortOutbound.IsNull() {
				*redirectPortOutbound = r.Networking.TransparentProxying.RedirectPortOutbound.ValueInt64()
			} else {
				redirectPortOutbound = nil
			}
			transparentProxying = &shared.TransparentProxying{
				DirectAccessServices: directAccessServices,
				IPFamilyMode:         ipFamilyMode,
				ReachableBackends:    reachableBackends,
				ReachableServices:    reachableServices,
				RedirectPortInbound:  redirectPortInbound,
				RedirectPortOutbound: redirectPortOutbound,
			}
		}
		networking = &shared.Networking{
			Address:             address1,
			Admin:               admin,
			AdvertisedAddress:   advertisedAddress,
			Gateway:             gateway,
			Inbound:             inbound,
			Outbound:            outbound,
			TransparentProxying: transparentProxying,
		}
	}
	var probes *shared.Probes
	if r.Probes != nil {
		endpoints := make([]shared.Endpoints, 0, len(r.Probes.Endpoints))
		for _, endpointsItem := range r.Probes.Endpoints {
			inboundPath := new(string)
			if !endpointsItem.InboundPath.IsUnknown() && !endpointsItem.InboundPath.IsNull() {
				*inboundPath = endpointsItem.InboundPath.ValueString()
			} else {
				inboundPath = nil
			}
			inboundPort := new(int64)
			if !endpointsItem.InboundPort.IsUnknown() && !endpointsItem.InboundPort.IsNull() {
				*inboundPort = endpointsItem.InboundPort.ValueInt64()
			} else {
				inboundPort = nil
			}
			path2 := new(string)
			if !endpointsItem.Path.IsUnknown() && !endpointsItem.Path.IsNull() {
				*path2 = endpointsItem.Path.ValueString()
			} else {
				path2 = nil
			}
			endpoints = append(endpoints, shared.Endpoints{
				InboundPath: inboundPath,
				InboundPort: inboundPort,
				Path:        path2,
			})
		}
		port7 := new(int64)
		if !r.Probes.Port.IsUnknown() && !r.Probes.Port.IsNull() {
			*port7 = r.Probes.Port.ValueInt64()
		} else {
			port7 = nil
		}
		probes = &shared.Probes{
			Endpoints: endpoints,
			Port:      port7,
		}
	}
	var typeVar2 string
	typeVar2 = r.Type.ValueString()

	out := shared.DataplaneItem{
		Labels:     labels,
		Mesh:       mesh,
		Metrics:    metrics,
		Name:       name2,
		Networking: networking,
		Probes:     probes,
		Type:       typeVar2,
	}

	return &out, diags
}

func (r *DataplaneResourceModel) ToOperationsCreateDataplaneRequest(ctx context.Context) (*operations.CreateDataplaneRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	dataplaneItem, dataplaneItemDiags := r.ToSharedDataplaneItem(ctx)
	diags.Append(dataplaneItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateDataplaneRequest{
		Mesh:          mesh,
		Name:          name,
		DataplaneItem: *dataplaneItem,
	}

	return &out, diags
}

func (r *DataplaneResourceModel) ToOperationsUpdateDataplaneRequest(ctx context.Context) (*operations.UpdateDataplaneRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	dataplaneItem, dataplaneItemDiags := r.ToSharedDataplaneItem(ctx)
	diags.Append(dataplaneItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateDataplaneRequest{
		Mesh:          mesh,
		Name:          name,
		DataplaneItem: *dataplaneItem,
	}

	return &out, diags
}

func (r *DataplaneResourceModel) ToOperationsGetDataplaneRequest(ctx context.Context) (*operations.GetDataplaneRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetDataplaneRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *DataplaneResourceModel) ToOperationsDeleteDataplaneRequest(ctx context.Context) (*operations.DeleteDataplaneRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteDataplaneRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *DataplaneResourceModel) RefreshFromSharedDataplaneCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.DataplaneCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *DataplaneResourceModel) RefreshFromSharedDataplaneItem(ctx context.Context, resp *shared.DataplaneItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.Mesh = types.StringValue(resp.Mesh)
		if resp.Metrics == nil {
			r.Metrics = nil
		} else {
			r.Metrics = &tfTypes.Metrics{}
			if resp.Metrics.Conf != nil {
				r.Metrics.Conf = &tfTypes.DataplaneItemConf{}
				if resp.Metrics.Conf.PrometheusMetricsBackendConfig != nil {
					r.Metrics.Conf.PrometheusMetricsBackendConfig = &tfTypes.PrometheusMetricsBackendConfig{}
					r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = []tfTypes.Aggregate{}
					if len(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) > len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[:len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate)]
					}
					for aggregateCount, aggregateItem := range resp.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate {
						var aggregate tfTypes.Aggregate
						aggregate.Address = types.StringPointerValue(aggregateItem.Address)
						aggregate.Enabled = types.BoolPointerValue(aggregateItem.Enabled)
						aggregate.Name = types.StringPointerValue(aggregateItem.Name)
						aggregate.Path = types.StringPointerValue(aggregateItem.Path)
						aggregate.Port = types.Int64PointerValue(aggregateItem.Port)
						if aggregateCount+1 > len(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = append(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate, aggregate)
						} else {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Address = aggregate.Address
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Enabled = aggregate.Enabled
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Name = aggregate.Name
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Path = aggregate.Path
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Port = aggregate.Port
						}
					}
					if resp.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy == nil {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy = nil
					} else {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy = &tfTypes.ConfEnvoy{}
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex = types.StringPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex)
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly = types.BoolPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly)
					}
					r.Metrics.Conf.PrometheusMetricsBackendConfig.Path = types.StringPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Path)
					r.Metrics.Conf.PrometheusMetricsBackendConfig.Port = types.Int64PointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Port)
					r.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS = types.BoolPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS)
					if len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Tags) > 0 {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Tags = make(map[string]types.String, len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Tags))
						for key1, value1 := range resp.Metrics.Conf.PrometheusMetricsBackendConfig.Tags {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Tags[key1] = types.StringValue(value1)
						}
					}
					if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS == nil {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS = nil
					} else {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS = &tfTypes.ConfTLS{}
						if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode != nil {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode = &tfTypes.ConfMode{}
							if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str != nil {
								r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str = types.StringPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str)
							}
							if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer != nil {
								r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer = types.Int64PointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer)
							}
						}
					}
				}
			}
			r.Metrics.Name = types.StringPointerValue(resp.Metrics.Name)
			r.Metrics.Type = types.StringPointerValue(resp.Metrics.Type)
		}
		r.Name = types.StringValue(resp.Name)
		if resp.Networking == nil {
			r.Networking = nil
		} else {
			r.Networking = &tfTypes.Networking{}
			r.Networking.Address = types.StringPointerValue(resp.Networking.Address)
			if resp.Networking.Admin == nil {
				r.Networking.Admin = nil
			} else {
				r.Networking.Admin = &tfTypes.Admin{}
				r.Networking.Admin.Port = types.Int64PointerValue(resp.Networking.Admin.Port)
			}
			r.Networking.AdvertisedAddress = types.StringPointerValue(resp.Networking.AdvertisedAddress)
			if resp.Networking.Gateway == nil {
				r.Networking.Gateway = nil
			} else {
				r.Networking.Gateway = &tfTypes.Gateway{}
				if len(resp.Networking.Gateway.Tags) > 0 {
					r.Networking.Gateway.Tags = make(map[string]types.String, len(resp.Networking.Gateway.Tags))
					for key2, value2 := range resp.Networking.Gateway.Tags {
						r.Networking.Gateway.Tags[key2] = types.StringValue(value2)
					}
				}
				if resp.Networking.Gateway.Type != nil {
					r.Networking.Gateway.Type = &tfTypes.ConfMode{}
					if resp.Networking.Gateway.Type.Str != nil {
						r.Networking.Gateway.Type.Str = types.StringPointerValue(resp.Networking.Gateway.Type.Str)
					}
					if resp.Networking.Gateway.Type.Integer != nil {
						r.Networking.Gateway.Type.Integer = types.Int64PointerValue(resp.Networking.Gateway.Type.Integer)
					}
				}
			}
			r.Networking.Inbound = []tfTypes.DataplaneItemInbound{}
			if len(r.Networking.Inbound) > len(resp.Networking.Inbound) {
				r.Networking.Inbound = r.Networking.Inbound[:len(resp.Networking.Inbound)]
			}
			for inboundCount, inboundItem := range resp.Networking.Inbound {
				var inbound tfTypes.DataplaneItemInbound
				inbound.Address = types.StringPointerValue(inboundItem.Address)
				if inboundItem.Health == nil {
					inbound.Health = nil
				} else {
					inbound.Health = &tfTypes.Health{}
					inbound.Health.Ready = types.BoolPointerValue(inboundItem.Health.Ready)
				}
				inbound.Name = types.StringPointerValue(inboundItem.Name)
				inbound.Port = types.Int64PointerValue(inboundItem.Port)
				inbound.ServiceAddress = types.StringPointerValue(inboundItem.ServiceAddress)
				inbound.ServicePort = types.Int64PointerValue(inboundItem.ServicePort)
				if inboundItem.ServiceProbe == nil {
					inbound.ServiceProbe = nil
				} else {
					inbound.ServiceProbe = &tfTypes.ServiceProbe{}
					inbound.ServiceProbe.HealthyThreshold = types.Int64PointerValue(inboundItem.ServiceProbe.HealthyThreshold)
					if inboundItem.ServiceProbe.Interval == nil {
						inbound.ServiceProbe.Interval = nil
					} else {
						inbound.ServiceProbe.Interval = &tfTypes.Interval{}
						inbound.ServiceProbe.Interval.Nanos = types.Int64PointerValue(inboundItem.ServiceProbe.Interval.Nanos)
						inbound.ServiceProbe.Interval.Seconds = types.Int64PointerValue(inboundItem.ServiceProbe.Interval.Seconds)
					}
					if inboundItem.ServiceProbe.TCP == nil {
						inbound.ServiceProbe.TCP = nil
					} else {
						inbound.ServiceProbe.TCP = &tfTypes.DataplaneItemTCP{}
					}
					if inboundItem.ServiceProbe.Timeout == nil {
						inbound.ServiceProbe.Timeout = nil
					} else {
						inbound.ServiceProbe.Timeout = &tfTypes.Interval{}
						inbound.ServiceProbe.Timeout.Nanos = types.Int64PointerValue(inboundItem.ServiceProbe.Timeout.Nanos)
						inbound.ServiceProbe.Timeout.Seconds = types.Int64PointerValue(inboundItem.ServiceProbe.Timeout.Seconds)
					}
					inbound.ServiceProbe.UnhealthyThreshold = types.Int64PointerValue(inboundItem.ServiceProbe.UnhealthyThreshold)
				}
				if inboundItem.State != nil {
					inbound.State = &tfTypes.ConfMode{}
					if inboundItem.State.Str != nil {
						inbound.State.Str = types.StringPointerValue(inboundItem.State.Str)
					}
					if inboundItem.State.Integer != nil {
						inbound.State.Integer = types.Int64PointerValue(inboundItem.State.Integer)
					}
				}
				if len(inboundItem.Tags) > 0 {
					inbound.Tags = make(map[string]types.String, len(inboundItem.Tags))
					for key3, value3 := range inboundItem.Tags {
						inbound.Tags[key3] = types.StringValue(value3)
					}
				}
				if inboundCount+1 > len(r.Networking.Inbound) {
					r.Networking.Inbound = append(r.Networking.Inbound, inbound)
				} else {
					r.Networking.Inbound[inboundCount].Address = inbound.Address
					r.Networking.Inbound[inboundCount].Health = inbound.Health
					r.Networking.Inbound[inboundCount].Name = inbound.Name
					r.Networking.Inbound[inboundCount].Port = inbound.Port
					r.Networking.Inbound[inboundCount].ServiceAddress = inbound.ServiceAddress
					r.Networking.Inbound[inboundCount].ServicePort = inbound.ServicePort
					r.Networking.Inbound[inboundCount].ServiceProbe = inbound.ServiceProbe
					r.Networking.Inbound[inboundCount].State = inbound.State
					r.Networking.Inbound[inboundCount].Tags = inbound.Tags
				}
			}
			r.Networking.Outbound = []tfTypes.Outbound{}
			if len(r.Networking.Outbound) > len(resp.Networking.Outbound) {
				r.Networking.Outbound = r.Networking.Outbound[:len(resp.Networking.Outbound)]
			}
			for outboundCount, outboundItem := range resp.Networking.Outbound {
				var outbound tfTypes.Outbound
				outbound.Address = types.StringPointerValue(outboundItem.Address)
				if outboundItem.BackendRef == nil {
					outbound.BackendRef = nil
				} else {
					outbound.BackendRef = &tfTypes.BackendRef{}
					outbound.BackendRef.Kind = types.StringPointerValue(outboundItem.BackendRef.Kind)
					if len(outboundItem.BackendRef.Labels) > 0 {
						outbound.BackendRef.Labels = make(map[string]types.String, len(outboundItem.BackendRef.Labels))
						for key4, value4 := range outboundItem.BackendRef.Labels {
							outbound.BackendRef.Labels[key4] = types.StringValue(value4)
						}
					}
					outbound.BackendRef.Name = types.StringPointerValue(outboundItem.BackendRef.Name)
					outbound.BackendRef.Port = types.Int64PointerValue(outboundItem.BackendRef.Port)
				}
				outbound.Port = types.Int64PointerValue(outboundItem.Port)
				if len(outboundItem.Tags) > 0 {
					outbound.Tags = make(map[string]types.String, len(outboundItem.Tags))
					for key5, value5 := range outboundItem.Tags {
						outbound.Tags[key5] = types.StringValue(value5)
					}
				}
				if outboundCount+1 > len(r.Networking.Outbound) {
					r.Networking.Outbound = append(r.Networking.Outbound, outbound)
				} else {
					r.Networking.Outbound[outboundCount].Address = outbound.Address
					r.Networking.Outbound[outboundCount].BackendRef = outbound.BackendRef
					r.Networking.Outbound[outboundCount].Port = outbound.Port
					r.Networking.Outbound[outboundCount].Tags = outbound.Tags
				}
			}
			if resp.Networking.TransparentProxying == nil {
				r.Networking.TransparentProxying = nil
			} else {
				r.Networking.TransparentProxying = &tfTypes.TransparentProxying{}
				r.Networking.TransparentProxying.DirectAccessServices = make([]types.String, 0, len(resp.Networking.TransparentProxying.DirectAccessServices))
				for _, v := range resp.Networking.TransparentProxying.DirectAccessServices {
					r.Networking.TransparentProxying.DirectAccessServices = append(r.Networking.TransparentProxying.DirectAccessServices, types.StringValue(v))
				}
				if resp.Networking.TransparentProxying.IPFamilyMode != nil {
					r.Networking.TransparentProxying.IPFamilyMode = &tfTypes.ConfMode{}
					if resp.Networking.TransparentProxying.IPFamilyMode.Str != nil {
						r.Networking.TransparentProxying.IPFamilyMode.Str = types.StringPointerValue(resp.Networking.TransparentProxying.IPFamilyMode.Str)
					}
					if resp.Networking.TransparentProxying.IPFamilyMode.Integer != nil {
						r.Networking.TransparentProxying.IPFamilyMode.Integer = types.Int64PointerValue(resp.Networking.TransparentProxying.IPFamilyMode.Integer)
					}
				}
				if resp.Networking.TransparentProxying.ReachableBackends == nil {
					r.Networking.TransparentProxying.ReachableBackends = nil
				} else {
					r.Networking.TransparentProxying.ReachableBackends = &tfTypes.ReachableBackends{}
					r.Networking.TransparentProxying.ReachableBackends.Refs = []tfTypes.Refs{}
					if len(r.Networking.TransparentProxying.ReachableBackends.Refs) > len(resp.Networking.TransparentProxying.ReachableBackends.Refs) {
						r.Networking.TransparentProxying.ReachableBackends.Refs = r.Networking.TransparentProxying.ReachableBackends.Refs[:len(resp.Networking.TransparentProxying.ReachableBackends.Refs)]
					}
					for refsCount, refsItem := range resp.Networking.TransparentProxying.ReachableBackends.Refs {
						var refs tfTypes.Refs
						refs.Kind = types.StringPointerValue(refsItem.Kind)
						if len(refsItem.Labels) > 0 {
							refs.Labels = make(map[string]types.String, len(refsItem.Labels))
							for key6, value6 := range refsItem.Labels {
								refs.Labels[key6] = types.StringValue(value6)
							}
						}
						refs.Name = types.StringPointerValue(refsItem.Name)
						refs.Namespace = types.StringPointerValue(refsItem.Namespace)
						refs.Port = types.Int64PointerValue(refsItem.Port)
						if refsCount+1 > len(r.Networking.TransparentProxying.ReachableBackends.Refs) {
							r.Networking.TransparentProxying.ReachableBackends.Refs = append(r.Networking.TransparentProxying.ReachableBackends.Refs, refs)
						} else {
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Kind = refs.Kind
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Labels = refs.Labels
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Name = refs.Name
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Namespace = refs.Namespace
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Port = refs.Port
						}
					}
				}
				r.Networking.TransparentProxying.ReachableServices = make([]types.String, 0, len(resp.Networking.TransparentProxying.ReachableServices))
				for _, v := range resp.Networking.TransparentProxying.ReachableServices {
					r.Networking.TransparentProxying.ReachableServices = append(r.Networking.TransparentProxying.ReachableServices, types.StringValue(v))
				}
				r.Networking.TransparentProxying.RedirectPortInbound = types.Int64PointerValue(resp.Networking.TransparentProxying.RedirectPortInbound)
				r.Networking.TransparentProxying.RedirectPortOutbound = types.Int64PointerValue(resp.Networking.TransparentProxying.RedirectPortOutbound)
			}
		}
		if resp.Probes == nil {
			r.Probes = nil
		} else {
			r.Probes = &tfTypes.Probes{}
			r.Probes.Endpoints = []tfTypes.Endpoints{}
			if len(r.Probes.Endpoints) > len(resp.Probes.Endpoints) {
				r.Probes.Endpoints = r.Probes.Endpoints[:len(resp.Probes.Endpoints)]
			}
			for endpointsCount, endpointsItem := range resp.Probes.Endpoints {
				var endpoints tfTypes.Endpoints
				endpoints.InboundPath = types.StringPointerValue(endpointsItem.InboundPath)
				endpoints.InboundPort = types.Int64PointerValue(endpointsItem.InboundPort)
				endpoints.Path = types.StringPointerValue(endpointsItem.Path)
				if endpointsCount+1 > len(r.Probes.Endpoints) {
					r.Probes.Endpoints = append(r.Probes.Endpoints, endpoints)
				} else {
					r.Probes.Endpoints[endpointsCount].InboundPath = endpoints.InboundPath
					r.Probes.Endpoints[endpointsCount].InboundPort = endpoints.InboundPort
					r.Probes.Endpoints[endpointsCount].Path = endpoints.Path
				}
			}
			r.Probes.Port = types.Int64PointerValue(resp.Probes.Port)
		}
		r.Type = types.StringValue(resp.Type)
	}

	return diags
}
