// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *DataplaneDataSourceModel) ToOperationsGetDataplaneRequest(ctx context.Context) (*operations.GetDataplaneRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetDataplaneRequest{
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *DataplaneDataSourceModel) RefreshFromSharedDataplaneItem(ctx context.Context, resp *shared.DataplaneItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.Mesh = types.StringValue(resp.Mesh)
		if resp.Metrics == nil {
			r.Metrics = nil
		} else {
			r.Metrics = &tfTypes.Metrics{}
			if resp.Metrics.Conf != nil {
				r.Metrics.Conf = &tfTypes.DataplaneItemConf{}
				if resp.Metrics.Conf.PrometheusMetricsBackendConfig != nil {
					r.Metrics.Conf.PrometheusMetricsBackendConfig = &tfTypes.PrometheusMetricsBackendConfig{}
					r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = []tfTypes.Aggregate{}
					if len(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) > len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[:len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate)]
					}
					for aggregateCount, aggregateItem := range resp.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate {
						var aggregate tfTypes.Aggregate
						aggregate.Address = types.StringPointerValue(aggregateItem.Address)
						aggregate.Enabled = types.BoolPointerValue(aggregateItem.Enabled)
						aggregate.Name = types.StringPointerValue(aggregateItem.Name)
						aggregate.Path = types.StringPointerValue(aggregateItem.Path)
						aggregate.Port = types.Int64PointerValue(aggregateItem.Port)
						if aggregateCount+1 > len(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate) {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate = append(r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate, aggregate)
						} else {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Address = aggregate.Address
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Enabled = aggregate.Enabled
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Name = aggregate.Name
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Path = aggregate.Path
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Aggregate[aggregateCount].Port = aggregate.Port
						}
					}
					if resp.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy == nil {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy = nil
					} else {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy = &tfTypes.ConfEnvoy{}
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex = types.StringPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.FilterRegex)
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly = types.BoolPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Envoy.UsedOnly)
					}
					r.Metrics.Conf.PrometheusMetricsBackendConfig.Path = types.StringPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Path)
					r.Metrics.Conf.PrometheusMetricsBackendConfig.Port = types.Int64PointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Port)
					r.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS = types.BoolPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.SkipMTLS)
					if len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Tags) > 0 {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.Tags = make(map[string]types.String, len(resp.Metrics.Conf.PrometheusMetricsBackendConfig.Tags))
						for key1, value1 := range resp.Metrics.Conf.PrometheusMetricsBackendConfig.Tags {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.Tags[key1] = types.StringValue(value1)
						}
					}
					if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS == nil {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS = nil
					} else {
						r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS = &tfTypes.ConfTLS{}
						if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode != nil {
							r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode = &tfTypes.ConfMode{}
							if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str != nil {
								r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str = types.StringPointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Str)
							}
							if resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer != nil {
								r.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer = types.Int64PointerValue(resp.Metrics.Conf.PrometheusMetricsBackendConfig.TLS.Mode.Integer)
							}
						}
					}
				}
			}
			r.Metrics.Name = types.StringPointerValue(resp.Metrics.Name)
			r.Metrics.Type = types.StringPointerValue(resp.Metrics.Type)
		}
		r.Name = types.StringValue(resp.Name)
		if resp.Networking == nil {
			r.Networking = nil
		} else {
			r.Networking = &tfTypes.Networking{}
			r.Networking.Address = types.StringPointerValue(resp.Networking.Address)
			if resp.Networking.Admin == nil {
				r.Networking.Admin = nil
			} else {
				r.Networking.Admin = &tfTypes.Admin{}
				r.Networking.Admin.Port = types.Int64PointerValue(resp.Networking.Admin.Port)
			}
			r.Networking.AdvertisedAddress = types.StringPointerValue(resp.Networking.AdvertisedAddress)
			if resp.Networking.Gateway == nil {
				r.Networking.Gateway = nil
			} else {
				r.Networking.Gateway = &tfTypes.Gateway{}
				if len(resp.Networking.Gateway.Tags) > 0 {
					r.Networking.Gateway.Tags = make(map[string]types.String, len(resp.Networking.Gateway.Tags))
					for key2, value2 := range resp.Networking.Gateway.Tags {
						r.Networking.Gateway.Tags[key2] = types.StringValue(value2)
					}
				}
				if resp.Networking.Gateway.Type != nil {
					r.Networking.Gateway.Type = &tfTypes.ConfMode{}
					if resp.Networking.Gateway.Type.Str != nil {
						r.Networking.Gateway.Type.Str = types.StringPointerValue(resp.Networking.Gateway.Type.Str)
					}
					if resp.Networking.Gateway.Type.Integer != nil {
						r.Networking.Gateway.Type.Integer = types.Int64PointerValue(resp.Networking.Gateway.Type.Integer)
					}
				}
			}
			r.Networking.Inbound = []tfTypes.DataplaneItemInbound{}
			if len(r.Networking.Inbound) > len(resp.Networking.Inbound) {
				r.Networking.Inbound = r.Networking.Inbound[:len(resp.Networking.Inbound)]
			}
			for inboundCount, inboundItem := range resp.Networking.Inbound {
				var inbound tfTypes.DataplaneItemInbound
				inbound.Address = types.StringPointerValue(inboundItem.Address)
				if inboundItem.Health == nil {
					inbound.Health = nil
				} else {
					inbound.Health = &tfTypes.Health{}
					inbound.Health.Ready = types.BoolPointerValue(inboundItem.Health.Ready)
				}
				inbound.Name = types.StringPointerValue(inboundItem.Name)
				inbound.Port = types.Int64PointerValue(inboundItem.Port)
				inbound.ServiceAddress = types.StringPointerValue(inboundItem.ServiceAddress)
				inbound.ServicePort = types.Int64PointerValue(inboundItem.ServicePort)
				if inboundItem.ServiceProbe == nil {
					inbound.ServiceProbe = nil
				} else {
					inbound.ServiceProbe = &tfTypes.ServiceProbe{}
					inbound.ServiceProbe.HealthyThreshold = types.Int64PointerValue(inboundItem.ServiceProbe.HealthyThreshold)
					if inboundItem.ServiceProbe.Interval == nil {
						inbound.ServiceProbe.Interval = nil
					} else {
						inbound.ServiceProbe.Interval = &tfTypes.Interval{}
						inbound.ServiceProbe.Interval.Nanos = types.Int64PointerValue(inboundItem.ServiceProbe.Interval.Nanos)
						inbound.ServiceProbe.Interval.Seconds = types.Int64PointerValue(inboundItem.ServiceProbe.Interval.Seconds)
					}
					if inboundItem.ServiceProbe.TCP == nil {
						inbound.ServiceProbe.TCP = nil
					} else {
						inbound.ServiceProbe.TCP = &tfTypes.DataplaneItemTCP{}
					}
					if inboundItem.ServiceProbe.Timeout == nil {
						inbound.ServiceProbe.Timeout = nil
					} else {
						inbound.ServiceProbe.Timeout = &tfTypes.Interval{}
						inbound.ServiceProbe.Timeout.Nanos = types.Int64PointerValue(inboundItem.ServiceProbe.Timeout.Nanos)
						inbound.ServiceProbe.Timeout.Seconds = types.Int64PointerValue(inboundItem.ServiceProbe.Timeout.Seconds)
					}
					inbound.ServiceProbe.UnhealthyThreshold = types.Int64PointerValue(inboundItem.ServiceProbe.UnhealthyThreshold)
				}
				if inboundItem.State != nil {
					inbound.State = &tfTypes.ConfMode{}
					if inboundItem.State.Str != nil {
						inbound.State.Str = types.StringPointerValue(inboundItem.State.Str)
					}
					if inboundItem.State.Integer != nil {
						inbound.State.Integer = types.Int64PointerValue(inboundItem.State.Integer)
					}
				}
				if len(inboundItem.Tags) > 0 {
					inbound.Tags = make(map[string]types.String, len(inboundItem.Tags))
					for key3, value3 := range inboundItem.Tags {
						inbound.Tags[key3] = types.StringValue(value3)
					}
				}
				if inboundCount+1 > len(r.Networking.Inbound) {
					r.Networking.Inbound = append(r.Networking.Inbound, inbound)
				} else {
					r.Networking.Inbound[inboundCount].Address = inbound.Address
					r.Networking.Inbound[inboundCount].Health = inbound.Health
					r.Networking.Inbound[inboundCount].Name = inbound.Name
					r.Networking.Inbound[inboundCount].Port = inbound.Port
					r.Networking.Inbound[inboundCount].ServiceAddress = inbound.ServiceAddress
					r.Networking.Inbound[inboundCount].ServicePort = inbound.ServicePort
					r.Networking.Inbound[inboundCount].ServiceProbe = inbound.ServiceProbe
					r.Networking.Inbound[inboundCount].State = inbound.State
					r.Networking.Inbound[inboundCount].Tags = inbound.Tags
				}
			}
			r.Networking.Outbound = []tfTypes.Outbound{}
			if len(r.Networking.Outbound) > len(resp.Networking.Outbound) {
				r.Networking.Outbound = r.Networking.Outbound[:len(resp.Networking.Outbound)]
			}
			for outboundCount, outboundItem := range resp.Networking.Outbound {
				var outbound tfTypes.Outbound
				outbound.Address = types.StringPointerValue(outboundItem.Address)
				if outboundItem.BackendRef == nil {
					outbound.BackendRef = nil
				} else {
					outbound.BackendRef = &tfTypes.BackendRef{}
					outbound.BackendRef.Kind = types.StringPointerValue(outboundItem.BackendRef.Kind)
					if len(outboundItem.BackendRef.Labels) > 0 {
						outbound.BackendRef.Labels = make(map[string]types.String, len(outboundItem.BackendRef.Labels))
						for key4, value4 := range outboundItem.BackendRef.Labels {
							outbound.BackendRef.Labels[key4] = types.StringValue(value4)
						}
					}
					outbound.BackendRef.Name = types.StringPointerValue(outboundItem.BackendRef.Name)
					outbound.BackendRef.Port = types.Int64PointerValue(outboundItem.BackendRef.Port)
				}
				outbound.Port = types.Int64PointerValue(outboundItem.Port)
				if len(outboundItem.Tags) > 0 {
					outbound.Tags = make(map[string]types.String, len(outboundItem.Tags))
					for key5, value5 := range outboundItem.Tags {
						outbound.Tags[key5] = types.StringValue(value5)
					}
				}
				if outboundCount+1 > len(r.Networking.Outbound) {
					r.Networking.Outbound = append(r.Networking.Outbound, outbound)
				} else {
					r.Networking.Outbound[outboundCount].Address = outbound.Address
					r.Networking.Outbound[outboundCount].BackendRef = outbound.BackendRef
					r.Networking.Outbound[outboundCount].Port = outbound.Port
					r.Networking.Outbound[outboundCount].Tags = outbound.Tags
				}
			}
			if resp.Networking.TransparentProxying == nil {
				r.Networking.TransparentProxying = nil
			} else {
				r.Networking.TransparentProxying = &tfTypes.TransparentProxying{}
				r.Networking.TransparentProxying.DirectAccessServices = make([]types.String, 0, len(resp.Networking.TransparentProxying.DirectAccessServices))
				for _, v := range resp.Networking.TransparentProxying.DirectAccessServices {
					r.Networking.TransparentProxying.DirectAccessServices = append(r.Networking.TransparentProxying.DirectAccessServices, types.StringValue(v))
				}
				if resp.Networking.TransparentProxying.IPFamilyMode != nil {
					r.Networking.TransparentProxying.IPFamilyMode = &tfTypes.ConfMode{}
					if resp.Networking.TransparentProxying.IPFamilyMode.Str != nil {
						r.Networking.TransparentProxying.IPFamilyMode.Str = types.StringPointerValue(resp.Networking.TransparentProxying.IPFamilyMode.Str)
					}
					if resp.Networking.TransparentProxying.IPFamilyMode.Integer != nil {
						r.Networking.TransparentProxying.IPFamilyMode.Integer = types.Int64PointerValue(resp.Networking.TransparentProxying.IPFamilyMode.Integer)
					}
				}
				if resp.Networking.TransparentProxying.ReachableBackends == nil {
					r.Networking.TransparentProxying.ReachableBackends = nil
				} else {
					r.Networking.TransparentProxying.ReachableBackends = &tfTypes.ReachableBackends{}
					r.Networking.TransparentProxying.ReachableBackends.Refs = []tfTypes.Refs{}
					if len(r.Networking.TransparentProxying.ReachableBackends.Refs) > len(resp.Networking.TransparentProxying.ReachableBackends.Refs) {
						r.Networking.TransparentProxying.ReachableBackends.Refs = r.Networking.TransparentProxying.ReachableBackends.Refs[:len(resp.Networking.TransparentProxying.ReachableBackends.Refs)]
					}
					for refsCount, refsItem := range resp.Networking.TransparentProxying.ReachableBackends.Refs {
						var refs tfTypes.Refs
						refs.Kind = types.StringPointerValue(refsItem.Kind)
						if len(refsItem.Labels) > 0 {
							refs.Labels = make(map[string]types.String, len(refsItem.Labels))
							for key6, value6 := range refsItem.Labels {
								refs.Labels[key6] = types.StringValue(value6)
							}
						}
						refs.Name = types.StringPointerValue(refsItem.Name)
						refs.Namespace = types.StringPointerValue(refsItem.Namespace)
						refs.Port = types.Int64PointerValue(refsItem.Port)
						if refsCount+1 > len(r.Networking.TransparentProxying.ReachableBackends.Refs) {
							r.Networking.TransparentProxying.ReachableBackends.Refs = append(r.Networking.TransparentProxying.ReachableBackends.Refs, refs)
						} else {
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Kind = refs.Kind
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Labels = refs.Labels
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Name = refs.Name
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Namespace = refs.Namespace
							r.Networking.TransparentProxying.ReachableBackends.Refs[refsCount].Port = refs.Port
						}
					}
				}
				r.Networking.TransparentProxying.ReachableServices = make([]types.String, 0, len(resp.Networking.TransparentProxying.ReachableServices))
				for _, v := range resp.Networking.TransparentProxying.ReachableServices {
					r.Networking.TransparentProxying.ReachableServices = append(r.Networking.TransparentProxying.ReachableServices, types.StringValue(v))
				}
				r.Networking.TransparentProxying.RedirectPortInbound = types.Int64PointerValue(resp.Networking.TransparentProxying.RedirectPortInbound)
				r.Networking.TransparentProxying.RedirectPortOutbound = types.Int64PointerValue(resp.Networking.TransparentProxying.RedirectPortOutbound)
			}
		}
		if resp.Probes == nil {
			r.Probes = nil
		} else {
			r.Probes = &tfTypes.Probes{}
			r.Probes.Endpoints = []tfTypes.Endpoints{}
			if len(r.Probes.Endpoints) > len(resp.Probes.Endpoints) {
				r.Probes.Endpoints = r.Probes.Endpoints[:len(resp.Probes.Endpoints)]
			}
			for endpointsCount, endpointsItem := range resp.Probes.Endpoints {
				var endpoints tfTypes.Endpoints
				endpoints.InboundPath = types.StringPointerValue(endpointsItem.InboundPath)
				endpoints.InboundPort = types.Int64PointerValue(endpointsItem.InboundPort)
				endpoints.Path = types.StringPointerValue(endpointsItem.Path)
				if endpointsCount+1 > len(r.Probes.Endpoints) {
					r.Probes.Endpoints = append(r.Probes.Endpoints, endpoints)
				} else {
					r.Probes.Endpoints[endpointsCount].InboundPath = endpoints.InboundPath
					r.Probes.Endpoints[endpointsCount].InboundPort = endpoints.InboundPort
					r.Probes.Endpoints[endpointsCount].Path = endpoints.Path
				}
			}
			r.Probes.Port = types.Int64PointerValue(resp.Probes.Port)
		}
		r.Type = types.StringValue(resp.Type)
	}

	return diags
}
