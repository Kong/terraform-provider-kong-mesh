// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	tfTypes "github.com/kong/terraform-provider-kong-mesh/internal/provider/types"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/models/shared"
)

func (r *AccessRoleResourceModel) RefreshFromSharedAccessRoleCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.AccessRoleCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *AccessRoleResourceModel) RefreshFromSharedAccessRoleItem(ctx context.Context, resp *shared.AccessRoleItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringValue(value)
			}
		}
		r.Name = types.StringValue(resp.Name)
		if resp.Rules != nil {
			r.Rules = []tfTypes.AccessRoleItemRules{}

			for _, rulesItem := range resp.Rules {
				var rules tfTypes.AccessRoleItemRules

				if rulesItem.Access != nil {
					rules.Access = []tfTypes.Access{}

					for _, accessItem := range rulesItem.Access {
						var access tfTypes.Access

						if accessItem.Str != nil {
							access.Str = types.StringPointerValue(accessItem.Str)
						}
						if accessItem.Integer != nil {
							access.Integer = types.Int64PointerValue(accessItem.Integer)
						}

						rules.Access = append(rules.Access, access)
					}
				}
				rules.Mesh = types.StringPointerValue(rulesItem.Mesh)
				if rulesItem.Names != nil {
					rules.Names = make([]types.String, 0, len(rulesItem.Names))
					for _, v := range rulesItem.Names {
						rules.Names = append(rules.Names, types.StringValue(v))
					}
				}
				if rulesItem.Types != nil {
					rules.Types = make([]types.String, 0, len(rulesItem.Types))
					for _, v := range rulesItem.Types {
						rules.Types = append(rules.Types, types.StringValue(v))
					}
				}
				if rulesItem.When != nil {
					rules.When = []tfTypes.When{}

					for _, whenItem := range rulesItem.When {
						var when tfTypes.When

						if whenItem.Destinations == nil {
							when.Destinations = nil
						} else {
							when.Destinations = &tfTypes.Destinations{}
							if len(whenItem.Destinations.Match) > 0 {
								when.Destinations.Match = make(map[string]types.String, len(whenItem.Destinations.Match))
								for key1, value1 := range whenItem.Destinations.Match {
									when.Destinations.Match[key1] = types.StringValue(value1)
								}
							}
						}
						if whenItem.DpToken == nil {
							when.DpToken = nil
						} else {
							when.DpToken = &tfTypes.DpToken{}
							if whenItem.DpToken.Tags != nil {
								when.DpToken.Tags = []tfTypes.AccessRoleItemTags{}

								for _, tagsItem := range whenItem.DpToken.Tags {
									var tags tfTypes.AccessRoleItemTags

									tags.Name = types.StringPointerValue(tagsItem.Name)
									tags.Value = types.StringPointerValue(tagsItem.Value)

									when.DpToken.Tags = append(when.DpToken.Tags, tags)
								}
							}
						}
						if whenItem.From == nil {
							when.From = nil
						} else {
							when.From = &tfTypes.AccessRoleItemFrom{}
							if whenItem.From.TargetRef == nil {
								when.From.TargetRef = nil
							} else {
								when.From.TargetRef = &tfTypes.AccessRoleItemRulesTargetRef{}
								when.From.TargetRef.Kind = types.StringPointerValue(whenItem.From.TargetRef.Kind)
								when.From.TargetRef.Mesh = types.StringPointerValue(whenItem.From.TargetRef.Mesh)
								when.From.TargetRef.Name = types.StringPointerValue(whenItem.From.TargetRef.Name)
								if len(whenItem.From.TargetRef.Tags) > 0 {
									when.From.TargetRef.Tags = make(map[string]types.String, len(whenItem.From.TargetRef.Tags))
									for key2, value2 := range whenItem.From.TargetRef.Tags {
										when.From.TargetRef.Tags[key2] = types.StringValue(value2)
									}
								}
							}
						}
						if whenItem.Selectors == nil {
							when.Selectors = nil
						} else {
							when.Selectors = &tfTypes.Destinations{}
							if len(whenItem.Selectors.Match) > 0 {
								when.Selectors.Match = make(map[string]types.String, len(whenItem.Selectors.Match))
								for key3, value3 := range whenItem.Selectors.Match {
									when.Selectors.Match[key3] = types.StringValue(value3)
								}
							}
						}
						if whenItem.Sources == nil {
							when.Sources = nil
						} else {
							when.Sources = &tfTypes.Destinations{}
							if len(whenItem.Sources.Match) > 0 {
								when.Sources.Match = make(map[string]types.String, len(whenItem.Sources.Match))
								for key4, value4 := range whenItem.Sources.Match {
									when.Sources.Match[key4] = types.StringValue(value4)
								}
							}
						}
						if whenItem.TargetRef == nil {
							when.TargetRef = nil
						} else {
							when.TargetRef = &tfTypes.AccessRoleItemRulesTargetRef{}
							when.TargetRef.Kind = types.StringPointerValue(whenItem.TargetRef.Kind)
							when.TargetRef.Mesh = types.StringPointerValue(whenItem.TargetRef.Mesh)
							when.TargetRef.Name = types.StringPointerValue(whenItem.TargetRef.Name)
							if len(whenItem.TargetRef.Tags) > 0 {
								when.TargetRef.Tags = make(map[string]types.String, len(whenItem.TargetRef.Tags))
								for key5, value5 := range whenItem.TargetRef.Tags {
									when.TargetRef.Tags[key5] = types.StringValue(value5)
								}
							}
						}
						if whenItem.To == nil {
							when.To = nil
						} else {
							when.To = &tfTypes.AccessRoleItemFrom{}
							if whenItem.To.TargetRef == nil {
								when.To.TargetRef = nil
							} else {
								when.To.TargetRef = &tfTypes.AccessRoleItemRulesTargetRef{}
								when.To.TargetRef.Kind = types.StringPointerValue(whenItem.To.TargetRef.Kind)
								when.To.TargetRef.Mesh = types.StringPointerValue(whenItem.To.TargetRef.Mesh)
								when.To.TargetRef.Name = types.StringPointerValue(whenItem.To.TargetRef.Name)
								if len(whenItem.To.TargetRef.Tags) > 0 {
									when.To.TargetRef.Tags = make(map[string]types.String, len(whenItem.To.TargetRef.Tags))
									for key6, value6 := range whenItem.To.TargetRef.Tags {
										when.To.TargetRef.Tags[key6] = types.StringValue(value6)
									}
								}
							}
						}

						rules.When = append(rules.When, when)
					}
				}

				r.Rules = append(r.Rules, rules)
			}
		}
		r.Type = types.StringValue(resp.Type)
	}

	return diags
}

func (r *AccessRoleResourceModel) ToOperationsDeleteAccessRoleRequest(ctx context.Context) (*operations.DeleteAccessRoleRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteAccessRoleRequest{
		Name: name,
	}

	return &out, diags
}

func (r *AccessRoleResourceModel) ToOperationsGetAccessRoleRequest(ctx context.Context) (*operations.GetAccessRoleRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	out := operations.GetAccessRoleRequest{
		Name: name,
	}

	return &out, diags
}

func (r *AccessRoleResourceModel) ToOperationsPutAccessRoleRequest(ctx context.Context) (*operations.PutAccessRoleRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var name string
	name = r.Name.ValueString()

	accessRoleItem, accessRoleItemDiags := r.ToSharedAccessRoleItem(ctx)
	diags.Append(accessRoleItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutAccessRoleRequest{
		Name:           name,
		AccessRoleItem: *accessRoleItem,
	}

	return &out, diags
}

func (r *AccessRoleResourceModel) ToSharedAccessRoleItem(ctx context.Context) (*shared.AccessRoleItem, diag.Diagnostics) {
	var diags diag.Diagnostics

	labels := make(map[string]string)
	for labelsKey, labelsValue := range r.Labels {
		var labelsInst string
		labelsInst = labelsValue.ValueString()

		labels[labelsKey] = labelsInst
	}
	var name string
	name = r.Name.ValueString()

	var rules []shared.AccessRoleItemRules
	if r.Rules != nil {
		rules = make([]shared.AccessRoleItemRules, 0, len(r.Rules))
		for _, rulesItem := range r.Rules {
			var access []shared.AccessRoleItemAccess
			if rulesItem.Access != nil {
				access = make([]shared.AccessRoleItemAccess, 0, len(rulesItem.Access))
				for _, accessItem := range rulesItem.Access {
					if !accessItem.Str.IsUnknown() && !accessItem.Str.IsNull() {
						var str string
						str = accessItem.Str.ValueString()

						access = append(access, shared.AccessRoleItemAccess{
							Str: &str,
						})
					}
					if !accessItem.Integer.IsUnknown() && !accessItem.Integer.IsNull() {
						var integer int64
						integer = accessItem.Integer.ValueInt64()

						access = append(access, shared.AccessRoleItemAccess{
							Integer: &integer,
						})
					}
				}
			}
			mesh := new(string)
			if !rulesItem.Mesh.IsUnknown() && !rulesItem.Mesh.IsNull() {
				*mesh = rulesItem.Mesh.ValueString()
			} else {
				mesh = nil
			}
			var names []string
			if rulesItem.Names != nil {
				names = make([]string, 0, len(rulesItem.Names))
				for _, namesItem := range rulesItem.Names {
					names = append(names, namesItem.ValueString())
				}
			}
			var typesVar []string
			if rulesItem.Types != nil {
				typesVar = make([]string, 0, len(rulesItem.Types))
				for _, typesItem := range rulesItem.Types {
					typesVar = append(typesVar, typesItem.ValueString())
				}
			}
			var when []shared.When
			if rulesItem.When != nil {
				when = make([]shared.When, 0, len(rulesItem.When))
				for _, whenItem := range rulesItem.When {
					var destinations *shared.Destinations
					if whenItem.Destinations != nil {
						match := make(map[string]string)
						for matchKey, matchValue := range whenItem.Destinations.Match {
							var matchInst string
							matchInst = matchValue.ValueString()

							match[matchKey] = matchInst
						}
						destinations = &shared.Destinations{
							Match: match,
						}
					}
					var dpToken *shared.DpToken
					if whenItem.DpToken != nil {
						var tags []shared.AccessRoleItemTags
						if whenItem.DpToken.Tags != nil {
							tags = make([]shared.AccessRoleItemTags, 0, len(whenItem.DpToken.Tags))
							for _, tagsItem := range whenItem.DpToken.Tags {
								name1 := new(string)
								if !tagsItem.Name.IsUnknown() && !tagsItem.Name.IsNull() {
									*name1 = tagsItem.Name.ValueString()
								} else {
									name1 = nil
								}
								value := new(string)
								if !tagsItem.Value.IsUnknown() && !tagsItem.Value.IsNull() {
									*value = tagsItem.Value.ValueString()
								} else {
									value = nil
								}
								tags = append(tags, shared.AccessRoleItemTags{
									Name:  name1,
									Value: value,
								})
							}
						}
						dpToken = &shared.DpToken{
							Tags: tags,
						}
					}
					var from *shared.AccessRoleItemFrom
					if whenItem.From != nil {
						var targetRef *shared.AccessRoleItemRulesTargetRef
						if whenItem.From.TargetRef != nil {
							kind := new(string)
							if !whenItem.From.TargetRef.Kind.IsUnknown() && !whenItem.From.TargetRef.Kind.IsNull() {
								*kind = whenItem.From.TargetRef.Kind.ValueString()
							} else {
								kind = nil
							}
							mesh1 := new(string)
							if !whenItem.From.TargetRef.Mesh.IsUnknown() && !whenItem.From.TargetRef.Mesh.IsNull() {
								*mesh1 = whenItem.From.TargetRef.Mesh.ValueString()
							} else {
								mesh1 = nil
							}
							name2 := new(string)
							if !whenItem.From.TargetRef.Name.IsUnknown() && !whenItem.From.TargetRef.Name.IsNull() {
								*name2 = whenItem.From.TargetRef.Name.ValueString()
							} else {
								name2 = nil
							}
							tags1 := make(map[string]string)
							for tagsKey, tagsValue := range whenItem.From.TargetRef.Tags {
								var tagsInst string
								tagsInst = tagsValue.ValueString()

								tags1[tagsKey] = tagsInst
							}
							targetRef = &shared.AccessRoleItemRulesTargetRef{
								Kind: kind,
								Mesh: mesh1,
								Name: name2,
								Tags: tags1,
							}
						}
						from = &shared.AccessRoleItemFrom{
							TargetRef: targetRef,
						}
					}
					var selectors *shared.AccessRoleItemSelectors
					if whenItem.Selectors != nil {
						match1 := make(map[string]string)
						for matchKey1, matchValue1 := range whenItem.Selectors.Match {
							var matchInst1 string
							matchInst1 = matchValue1.ValueString()

							match1[matchKey1] = matchInst1
						}
						selectors = &shared.AccessRoleItemSelectors{
							Match: match1,
						}
					}
					var sources *shared.Sources
					if whenItem.Sources != nil {
						match2 := make(map[string]string)
						for matchKey2, matchValue2 := range whenItem.Sources.Match {
							var matchInst2 string
							matchInst2 = matchValue2.ValueString()

							match2[matchKey2] = matchInst2
						}
						sources = &shared.Sources{
							Match: match2,
						}
					}
					var targetRef1 *shared.AccessRoleItemTargetRef
					if whenItem.TargetRef != nil {
						kind1 := new(string)
						if !whenItem.TargetRef.Kind.IsUnknown() && !whenItem.TargetRef.Kind.IsNull() {
							*kind1 = whenItem.TargetRef.Kind.ValueString()
						} else {
							kind1 = nil
						}
						mesh2 := new(string)
						if !whenItem.TargetRef.Mesh.IsUnknown() && !whenItem.TargetRef.Mesh.IsNull() {
							*mesh2 = whenItem.TargetRef.Mesh.ValueString()
						} else {
							mesh2 = nil
						}
						name3 := new(string)
						if !whenItem.TargetRef.Name.IsUnknown() && !whenItem.TargetRef.Name.IsNull() {
							*name3 = whenItem.TargetRef.Name.ValueString()
						} else {
							name3 = nil
						}
						tags2 := make(map[string]string)
						for tagsKey1, tagsValue1 := range whenItem.TargetRef.Tags {
							var tagsInst1 string
							tagsInst1 = tagsValue1.ValueString()

							tags2[tagsKey1] = tagsInst1
						}
						targetRef1 = &shared.AccessRoleItemTargetRef{
							Kind: kind1,
							Mesh: mesh2,
							Name: name3,
							Tags: tags2,
						}
					}
					var to *shared.AccessRoleItemTo
					if whenItem.To != nil {
						var targetRef2 *shared.AccessRoleItemRulesWhenTargetRef
						if whenItem.To.TargetRef != nil {
							kind2 := new(string)
							if !whenItem.To.TargetRef.Kind.IsUnknown() && !whenItem.To.TargetRef.Kind.IsNull() {
								*kind2 = whenItem.To.TargetRef.Kind.ValueString()
							} else {
								kind2 = nil
							}
							mesh3 := new(string)
							if !whenItem.To.TargetRef.Mesh.IsUnknown() && !whenItem.To.TargetRef.Mesh.IsNull() {
								*mesh3 = whenItem.To.TargetRef.Mesh.ValueString()
							} else {
								mesh3 = nil
							}
							name4 := new(string)
							if !whenItem.To.TargetRef.Name.IsUnknown() && !whenItem.To.TargetRef.Name.IsNull() {
								*name4 = whenItem.To.TargetRef.Name.ValueString()
							} else {
								name4 = nil
							}
							tags3 := make(map[string]string)
							for tagsKey2, tagsValue2 := range whenItem.To.TargetRef.Tags {
								var tagsInst2 string
								tagsInst2 = tagsValue2.ValueString()

								tags3[tagsKey2] = tagsInst2
							}
							targetRef2 = &shared.AccessRoleItemRulesWhenTargetRef{
								Kind: kind2,
								Mesh: mesh3,
								Name: name4,
								Tags: tags3,
							}
						}
						to = &shared.AccessRoleItemTo{
							TargetRef: targetRef2,
						}
					}
					when = append(when, shared.When{
						Destinations: destinations,
						DpToken:      dpToken,
						From:         from,
						Selectors:    selectors,
						Sources:      sources,
						TargetRef:    targetRef1,
						To:           to,
					})
				}
			}
			rules = append(rules, shared.AccessRoleItemRules{
				Access: access,
				Mesh:   mesh,
				Names:  names,
				Types:  typesVar,
				When:   when,
			})
		}
	}
	var typeVar string
	typeVar = r.Type.ValueString()

	out := shared.AccessRoleItem{
		Labels: labels,
		Name:   name,
		Rules:  rules,
		Type:   typeVar,
	}

	return &out, diags
}
