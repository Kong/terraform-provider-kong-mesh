// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
)

// ConfAggregate - PrometheusAggregateMetricsConfig defines endpoints that should be scrapped by kuma-dp for prometheus metrics.
type ConfAggregate struct {
	// Address on which a service expose HTTP endpoint with Prometheus metrics.
	Address *string `json:"address,omitempty"`
	// If false then the application won't be scrapped. If nil, then it is treated
	// as true and kuma-dp scrapes metrics from the service.
	Enabled *bool `json:"enabled,omitempty"`
	// Name which identify given configuration.
	Name *string `json:"name,omitempty"`
	// Path on which a service expose HTTP endpoint with Prometheus metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a service expose HTTP endpoint with Prometheus metrics.
	Port *int64 `json:"port,omitempty"`
}

func (o *ConfAggregate) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *ConfAggregate) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *ConfAggregate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ConfAggregate) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *ConfAggregate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// PrometheusMetricsBackendConfigConfEnvoy - Configuration of Envoy's metrics.
type PrometheusMetricsBackendConfigConfEnvoy struct {
	// FilterRegex value that is going to be passed to Envoy for filtering
	// Envoy metrics.
	FilterRegex *string `json:"filterRegex,omitempty"`
	// If true then return metrics that Envoy has updated (counters incremented
	// at least once, gauges changed at least once, and histograms added to at
	// least once). If nil, then it is treated as false.
	UsedOnly *bool `json:"usedOnly,omitempty"`
}

func (o *PrometheusMetricsBackendConfigConfEnvoy) GetFilterRegex() *string {
	if o == nil {
		return nil
	}
	return o.FilterRegex
}

func (o *PrometheusMetricsBackendConfigConfEnvoy) GetUsedOnly() *bool {
	if o == nil {
		return nil
	}
	return o.UsedOnly
}

type PrometheusMetricsBackendConfigConfModeType string

const (
	PrometheusMetricsBackendConfigConfModeTypeStr     PrometheusMetricsBackendConfigConfModeType = "str"
	PrometheusMetricsBackendConfigConfModeTypeInteger PrometheusMetricsBackendConfigConfModeType = "integer"
)

// PrometheusMetricsBackendConfigConfMode - mode defines how configured is the TLS for Prometheus.
// Supported values, delegated, disabled, activeMTLSBackend. Default to
// `activeMTLSBackend`.
type PrometheusMetricsBackendConfigConfMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type PrometheusMetricsBackendConfigConfModeType
}

func CreatePrometheusMetricsBackendConfigConfModeStr(str string) PrometheusMetricsBackendConfigConfMode {
	typ := PrometheusMetricsBackendConfigConfModeTypeStr

	return PrometheusMetricsBackendConfigConfMode{
		Str:  &str,
		Type: typ,
	}
}

func CreatePrometheusMetricsBackendConfigConfModeInteger(integer int64) PrometheusMetricsBackendConfigConfMode {
	typ := PrometheusMetricsBackendConfigConfModeTypeInteger

	return PrometheusMetricsBackendConfigConfMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *PrometheusMetricsBackendConfigConfMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = PrometheusMetricsBackendConfigConfModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = PrometheusMetricsBackendConfigConfModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PrometheusMetricsBackendConfigConfMode", string(data))
}

func (u PrometheusMetricsBackendConfigConfMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type PrometheusMetricsBackendConfigConfMode: all fields are null")
}

// PrometheusMetricsBackendConfigConfDataplaneOverviewWithMetaTLS - Configuration of TLS for prometheus listener.
type PrometheusMetricsBackendConfigConfDataplaneOverviewWithMetaTLS struct {
	// mode defines how configured is the TLS for Prometheus.
	// Supported values, delegated, disabled, activeMTLSBackend. Default to
	// `activeMTLSBackend`.
	Mode *PrometheusMetricsBackendConfigConfMode `json:"mode,omitempty"`
}

func (o *PrometheusMetricsBackendConfigConfDataplaneOverviewWithMetaTLS) GetMode() *PrometheusMetricsBackendConfigConfMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

type ConfPrometheusMetricsBackendConfig struct {
	// Map with the configuration of applications which metrics are going to be
	// scrapped by kuma-dp.
	Aggregate []ConfAggregate `json:"aggregate,omitempty"`
	// Configuration of Envoy's metrics.
	Envoy *PrometheusMetricsBackendConfigConfEnvoy `json:"envoy,omitempty"`
	// Path on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Port *int64 `json:"port,omitempty"`
	// If true then endpoints for scraping metrics won't require mTLS even if mTLS
	// is enabled in Mesh. If nil, then it is treated as false.
	SkipMTLS *bool `json:"skipMTLS,omitempty"`
	// Tags associated with an application this dataplane is deployed next to,
	// e.g. service=web, version=1.0.
	// `service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Configuration of TLS for prometheus listener.
	TLS *PrometheusMetricsBackendConfigConfDataplaneOverviewWithMetaTLS `json:"tls,omitempty"`
}

func (o *ConfPrometheusMetricsBackendConfig) GetAggregate() []ConfAggregate {
	if o == nil {
		return nil
	}
	return o.Aggregate
}

func (o *ConfPrometheusMetricsBackendConfig) GetEnvoy() *PrometheusMetricsBackendConfigConfEnvoy {
	if o == nil {
		return nil
	}
	return o.Envoy
}

func (o *ConfPrometheusMetricsBackendConfig) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *ConfPrometheusMetricsBackendConfig) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *ConfPrometheusMetricsBackendConfig) GetSkipMTLS() *bool {
	if o == nil {
		return nil
	}
	return o.SkipMTLS
}

func (o *ConfPrometheusMetricsBackendConfig) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *ConfPrometheusMetricsBackendConfig) GetTLS() *PrometheusMetricsBackendConfigConfDataplaneOverviewWithMetaTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

type DataplaneOverviewWithMetaConfType string

const (
	DataplaneOverviewWithMetaConfTypeConfPrometheusMetricsBackendConfig DataplaneOverviewWithMetaConfType = "conf_PrometheusMetricsBackendConfig"
)

type DataplaneOverviewWithMetaConf struct {
	ConfPrometheusMetricsBackendConfig *ConfPrometheusMetricsBackendConfig `queryParam:"inline"`

	Type DataplaneOverviewWithMetaConfType
}

func CreateDataplaneOverviewWithMetaConfConfPrometheusMetricsBackendConfig(confPrometheusMetricsBackendConfig ConfPrometheusMetricsBackendConfig) DataplaneOverviewWithMetaConf {
	typ := DataplaneOverviewWithMetaConfTypeConfPrometheusMetricsBackendConfig

	return DataplaneOverviewWithMetaConf{
		ConfPrometheusMetricsBackendConfig: &confPrometheusMetricsBackendConfig,
		Type:                               typ,
	}
}

func (u *DataplaneOverviewWithMetaConf) UnmarshalJSON(data []byte) error {

	var confPrometheusMetricsBackendConfig ConfPrometheusMetricsBackendConfig = ConfPrometheusMetricsBackendConfig{}
	if err := utils.UnmarshalJSON(data, &confPrometheusMetricsBackendConfig, "", true, true); err == nil {
		u.ConfPrometheusMetricsBackendConfig = &confPrometheusMetricsBackendConfig
		u.Type = DataplaneOverviewWithMetaConfTypeConfPrometheusMetricsBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneOverviewWithMetaConf", string(data))
}

func (u DataplaneOverviewWithMetaConf) MarshalJSON() ([]byte, error) {
	if u.ConfPrometheusMetricsBackendConfig != nil {
		return utils.MarshalJSON(u.ConfPrometheusMetricsBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneOverviewWithMetaConf: all fields are null")
}

// DataplaneOverviewWithMetaMetrics - Configuration for metrics that should be collected and exposed by the
// data plane proxy.
//
// Settings defined here will override their respective defaults
// defined at a Mesh level.
type DataplaneOverviewWithMetaMetrics struct {
	Conf *DataplaneOverviewWithMetaConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.metrics.enabledBackend
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'prometheus')
	Type *string `json:"type,omitempty"`
}

func (o *DataplaneOverviewWithMetaMetrics) GetConf() *DataplaneOverviewWithMetaConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *DataplaneOverviewWithMetaMetrics) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *DataplaneOverviewWithMetaMetrics) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// DataplaneOverviewWithMetaAdmin - Admin describes configuration related to Envoy Admin API.
// Due to security, all the Envoy Admin endpoints are exposed only on
// localhost. Additionally, Envoy will expose `/ready` endpoint on
// `networking.address` for health checking systems to be able to check the
// state of Envoy. The rest of the endpoints exposed on `networking.address`
// are always protected by mTLS and only meant to be consumed internally by
// the control plane.
type DataplaneOverviewWithMetaAdmin struct {
	// Port on which Envoy Admin API server will be listening
	Port *int64 `json:"port,omitempty"`
}

func (o *DataplaneOverviewWithMetaAdmin) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type DataplaneOverviewWithMetaTypeType string

const (
	DataplaneOverviewWithMetaTypeTypeStr     DataplaneOverviewWithMetaTypeType = "str"
	DataplaneOverviewWithMetaTypeTypeInteger DataplaneOverviewWithMetaTypeType = "integer"
)

// DataplaneOverviewWithMetaType - Type of gateway this data plane proxy manages.
// There are two types: `DELEGATED` and `BUILTIN`. Defaults to
// `DELEGATED`.
//
// A `DELEGATED` gateway is an independently deployed proxy (e.g., Kong,
// Contour, etc) that receives inbound traffic that is not proxied by
// Kuma, and it sends outbound traffic into the data plane proxy.
//
// The `BUILTIN` gateway type causes the data plane proxy itself to be
// configured as a gateway.
//
// See https://kuma.io/docs/latest/explore/gateway/ for more information.
type DataplaneOverviewWithMetaType struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type DataplaneOverviewWithMetaTypeType
}

func CreateDataplaneOverviewWithMetaTypeStr(str string) DataplaneOverviewWithMetaType {
	typ := DataplaneOverviewWithMetaTypeTypeStr

	return DataplaneOverviewWithMetaType{
		Str:  &str,
		Type: typ,
	}
}

func CreateDataplaneOverviewWithMetaTypeInteger(integer int64) DataplaneOverviewWithMetaType {
	typ := DataplaneOverviewWithMetaTypeTypeInteger

	return DataplaneOverviewWithMetaType{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *DataplaneOverviewWithMetaType) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = DataplaneOverviewWithMetaTypeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = DataplaneOverviewWithMetaTypeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneOverviewWithMetaType", string(data))
}

func (u DataplaneOverviewWithMetaType) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneOverviewWithMetaType: all fields are null")
}

// DataplaneOverviewWithMetaGateway - Gateway describes a configuration of the gateway of the data plane proxy.
type DataplaneOverviewWithMetaGateway struct {
	// Tags associated with a gateway of this data plane to, e.g.
	// `kuma.io/service=gateway`, `env=prod`. `kuma.io/service` tag is
	// mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Type of gateway this data plane proxy manages.
	// There are two types: `DELEGATED` and `BUILTIN`. Defaults to
	// `DELEGATED`.
	//
	// A `DELEGATED` gateway is an independently deployed proxy (e.g., Kong,
	// Contour, etc) that receives inbound traffic that is not proxied by
	// Kuma, and it sends outbound traffic into the data plane proxy.
	//
	// The `BUILTIN` gateway type causes the data plane proxy itself to be
	// configured as a gateway.
	//
	// See https://kuma.io/docs/latest/explore/gateway/ for more information.
	Type *DataplaneOverviewWithMetaType `json:"type,omitempty"`
}

func (o *DataplaneOverviewWithMetaGateway) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *DataplaneOverviewWithMetaGateway) GetType() *DataplaneOverviewWithMetaType {
	if o == nil {
		return nil
	}
	return o.Type
}

// DataplaneOverviewWithMetaHealth - Health describes the status of an inbound.
// If 'health' is nil we consider data plane proxy as healthy.
// Unhealthy data plane proxies are excluded from Endpoints Discovery
// Service (EDS). On Kubernetes, it is filled automatically by the control
// plane if Pod has readiness probe configured. On Universal, it can be
// set by the external health checking system, but the most common way is
// to use service probes.
//
// See https://kuma.io/docs/latest/documentation/health for more
// information.
type DataplaneOverviewWithMetaHealth struct {
	// Ready indicates if the data plane proxy is ready to serve the
	// traffic.
	Ready *bool `json:"ready,omitempty"`
}

func (o *DataplaneOverviewWithMetaHealth) GetReady() *bool {
	if o == nil {
		return nil
	}
	return o.Ready
}

// DataplaneOverviewWithMetaInterval - Interval between consecutive health checks.
type DataplaneOverviewWithMetaInterval struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *DataplaneOverviewWithMetaInterval) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *DataplaneOverviewWithMetaInterval) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// DataplaneOverviewWithMetaTCP - Tcp checker tries to establish tcp connection with destination
type DataplaneOverviewWithMetaTCP struct {
}

// DataplaneOverviewWithMetaTimeout - Maximum time to wait for a health check response.
type DataplaneOverviewWithMetaTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *DataplaneOverviewWithMetaTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *DataplaneOverviewWithMetaTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// DataplaneOverviewWithMetaServiceProbe - ServiceProbe defines parameters for probing the service next to
// sidecar. When service probe is defined, Envoy will periodically health
// check the application next to it and report the status to the control
// plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so
// this is not used.
//
// See https://kuma.io/docs/latest/documentation/health for more
// information.
type DataplaneOverviewWithMetaServiceProbe struct {
	// Number of consecutive healthy checks before considering a host
	// healthy.
	HealthyThreshold *int64 `json:"healthyThreshold,omitempty"`
	// Interval between consecutive health checks.
	Interval *DataplaneOverviewWithMetaInterval `json:"interval,omitempty"`
	// Tcp checker tries to establish tcp connection with destination
	TCP *DataplaneOverviewWithMetaTCP `json:"tcp,omitempty"`
	// Maximum time to wait for a health check response.
	Timeout *DataplaneOverviewWithMetaTimeout `json:"timeout,omitempty"`
	// Number of consecutive unhealthy checks before considering a host
	// unhealthy.
	UnhealthyThreshold *int64 `json:"unhealthyThreshold,omitempty"`
}

func (o *DataplaneOverviewWithMetaServiceProbe) GetHealthyThreshold() *int64 {
	if o == nil {
		return nil
	}
	return o.HealthyThreshold
}

func (o *DataplaneOverviewWithMetaServiceProbe) GetInterval() *DataplaneOverviewWithMetaInterval {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *DataplaneOverviewWithMetaServiceProbe) GetTCP() *DataplaneOverviewWithMetaTCP {
	if o == nil {
		return nil
	}
	return o.TCP
}

func (o *DataplaneOverviewWithMetaServiceProbe) GetTimeout() *DataplaneOverviewWithMetaTimeout {
	if o == nil {
		return nil
	}
	return o.Timeout
}

func (o *DataplaneOverviewWithMetaServiceProbe) GetUnhealthyThreshold() *int64 {
	if o == nil {
		return nil
	}
	return o.UnhealthyThreshold
}

type DataplaneOverviewWithMetaStateType string

const (
	DataplaneOverviewWithMetaStateTypeStr     DataplaneOverviewWithMetaStateType = "str"
	DataplaneOverviewWithMetaStateTypeInteger DataplaneOverviewWithMetaStateType = "integer"
)

// DataplaneOverviewWithMetaState - State describes the current state of the listener.
type DataplaneOverviewWithMetaState struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type DataplaneOverviewWithMetaStateType
}

func CreateDataplaneOverviewWithMetaStateStr(str string) DataplaneOverviewWithMetaState {
	typ := DataplaneOverviewWithMetaStateTypeStr

	return DataplaneOverviewWithMetaState{
		Str:  &str,
		Type: typ,
	}
}

func CreateDataplaneOverviewWithMetaStateInteger(integer int64) DataplaneOverviewWithMetaState {
	typ := DataplaneOverviewWithMetaStateTypeInteger

	return DataplaneOverviewWithMetaState{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *DataplaneOverviewWithMetaState) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = DataplaneOverviewWithMetaStateTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = DataplaneOverviewWithMetaStateTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneOverviewWithMetaState", string(data))
}

func (u DataplaneOverviewWithMetaState) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneOverviewWithMetaState: all fields are null")
}

// DataplaneOverviewWithMetaInbound - Inbound describes a service implemented by the data plane proxy.
type DataplaneOverviewWithMetaInbound struct {
	// Address on which inbound listener will be exposed.
	// Defaults to `networking.address`.
	Address *string `json:"address,omitempty"`
	// Health describes the status of an inbound.
	// If 'health' is nil we consider data plane proxy as healthy.
	// Unhealthy data plane proxies are excluded from Endpoints Discovery
	// Service (EDS). On Kubernetes, it is filled automatically by the control
	// plane if Pod has readiness probe configured. On Universal, it can be
	// set by the external health checking system, but the most common way is
	// to use service probes.
	//
	// See https://kuma.io/docs/latest/documentation/health for more
	// information.
	Health *DataplaneOverviewWithMetaHealth `json:"health,omitempty"`
	// Name adds another way of referencing this port, usable with MeshService
	Name *string `json:"name,omitempty"`
	// Port of the inbound interface that will forward requests to the
	// service.
	//
	// When transparent proxying is used, it is a port on which the service is
	// listening to. When transparent proxying is not used, Envoy will bind to
	// this port.
	Port *int64 `json:"port,omitempty"`
	// Address of the service that requests will be forwarded to.
	// Defaults to 'inbound.address', since Kuma DP should be deployed next
	// to the service.
	ServiceAddress *string `json:"serviceAddress,omitempty"`
	// Port of the service that requests will be forwarded to.
	// Defaults to the same value as `port`.
	ServicePort *int64 `json:"servicePort,omitempty"`
	// ServiceProbe defines parameters for probing the service next to
	// sidecar. When service probe is defined, Envoy will periodically health
	// check the application next to it and report the status to the control
	// plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so
	// this is not used.
	//
	// See https://kuma.io/docs/latest/documentation/health for more
	// information.
	ServiceProbe *DataplaneOverviewWithMetaServiceProbe `json:"serviceProbe,omitempty"`
	// State describes the current state of the listener.
	State *DataplaneOverviewWithMetaState `json:"state,omitempty"`
	// Tags associated with an application this data plane proxy is deployed
	// next to, e.g. `kuma.io/service=web`, `version=1.0`. You can then
	// reference these tags in policies like MeshTrafficPermission.
	// `kuma.io/service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *DataplaneOverviewWithMetaInbound) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *DataplaneOverviewWithMetaInbound) GetHealth() *DataplaneOverviewWithMetaHealth {
	if o == nil {
		return nil
	}
	return o.Health
}

func (o *DataplaneOverviewWithMetaInbound) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *DataplaneOverviewWithMetaInbound) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DataplaneOverviewWithMetaInbound) GetServiceAddress() *string {
	if o == nil {
		return nil
	}
	return o.ServiceAddress
}

func (o *DataplaneOverviewWithMetaInbound) GetServicePort() *int64 {
	if o == nil {
		return nil
	}
	return o.ServicePort
}

func (o *DataplaneOverviewWithMetaInbound) GetServiceProbe() *DataplaneOverviewWithMetaServiceProbe {
	if o == nil {
		return nil
	}
	return o.ServiceProbe
}

func (o *DataplaneOverviewWithMetaInbound) GetState() *DataplaneOverviewWithMetaState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *DataplaneOverviewWithMetaInbound) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// DataplaneOverviewWithMetaBackendRef - BackendRef is a way to target MeshService.
// Experimental. Do not use on production yet.
type DataplaneOverviewWithMetaBackendRef struct {
	// Kind is a type of the object to target. Allowed: MeshService
	Kind *string `json:"kind,omitempty"`
	// Labels to select a single object.
	// If no object is selected then outbound is not created.
	// If multiple objects are selected then the oldest one is used.
	Labels map[string]string `json:"labels,omitempty"`
	// Name of the targeted object
	Name *string `json:"name,omitempty"`
	// Port of the targeted object. Required when kind is MeshService.
	Port *int64 `json:"port,omitempty"`
}

func (o *DataplaneOverviewWithMetaBackendRef) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *DataplaneOverviewWithMetaBackendRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *DataplaneOverviewWithMetaBackendRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *DataplaneOverviewWithMetaBackendRef) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// DataplaneOverviewWithMetaOutbound - Outbound describes a service consumed by the data plane proxy.
type DataplaneOverviewWithMetaOutbound struct {
	// IP on which the consumed service will be available to this data plane
	// proxy. On Kubernetes, it's usually ClusterIP of a Service or PodIP of a
	// Headless Service. Defaults to 127.0.0.1
	Address *string `json:"address,omitempty"`
	// BackendRef is a way to target MeshService.
	// Experimental. Do not use on production yet.
	BackendRef *DataplaneOverviewWithMetaBackendRef `json:"backendRef,omitempty"`
	// Port on which the consumed service will be available to this data plane
	// proxy. When transparent proxying is not used, Envoy will bind to this
	// port.
	Port *int64 `json:"port,omitempty"`
	// Tags of consumed data plane proxies.
	// `kuma.io/service` tag is required.
	// These tags can then be referenced in `destinations` section of policies
	// like TrafficRoute or in `to` section in policies like MeshAccessLog. It
	// is recommended to only use `kuma.io/service`. If you need to consume
	// specific data plane proxy of a service (for example: `version=v2`) the
	// better practice is to use TrafficRoute.
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *DataplaneOverviewWithMetaOutbound) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *DataplaneOverviewWithMetaOutbound) GetBackendRef() *DataplaneOverviewWithMetaBackendRef {
	if o == nil {
		return nil
	}
	return o.BackendRef
}

func (o *DataplaneOverviewWithMetaOutbound) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DataplaneOverviewWithMetaOutbound) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type DataplaneOverviewWithMetaIPFamilyModeType string

const (
	DataplaneOverviewWithMetaIPFamilyModeTypeStr     DataplaneOverviewWithMetaIPFamilyModeType = "str"
	DataplaneOverviewWithMetaIPFamilyModeTypeInteger DataplaneOverviewWithMetaIPFamilyModeType = "integer"
)

// DataplaneOverviewWithMetaIPFamilyMode - The IP family mode to enable for. Can be "IPv4" or "DualStack".
type DataplaneOverviewWithMetaIPFamilyMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type DataplaneOverviewWithMetaIPFamilyModeType
}

func CreateDataplaneOverviewWithMetaIPFamilyModeStr(str string) DataplaneOverviewWithMetaIPFamilyMode {
	typ := DataplaneOverviewWithMetaIPFamilyModeTypeStr

	return DataplaneOverviewWithMetaIPFamilyMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateDataplaneOverviewWithMetaIPFamilyModeInteger(integer int64) DataplaneOverviewWithMetaIPFamilyMode {
	typ := DataplaneOverviewWithMetaIPFamilyModeTypeInteger

	return DataplaneOverviewWithMetaIPFamilyMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *DataplaneOverviewWithMetaIPFamilyMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = DataplaneOverviewWithMetaIPFamilyModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = DataplaneOverviewWithMetaIPFamilyModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneOverviewWithMetaIPFamilyMode", string(data))
}

func (u DataplaneOverviewWithMetaIPFamilyMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneOverviewWithMetaIPFamilyMode: all fields are null")
}

type DataplaneOverviewWithMetaRefs struct {
	// Type of the backend: MeshService or MeshExternalService
	//
	// 	+required
	Kind *string `json:"kind,omitempty"`
	// Labels used to select backends
	//
	// 	+optional
	Labels map[string]string `json:"labels,omitempty"`
	// Name of the backend.
	//
	// 	+optional
	Name *string `json:"name,omitempty"`
	// Namespace of the backend. Might be empty
	//
	// 	+optional
	Namespace *string `json:"namespace,omitempty"`
	// Port of the backend.
	//
	// 	+optional
	Port *int64 `json:"port,omitempty"`
}

func (o *DataplaneOverviewWithMetaRefs) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *DataplaneOverviewWithMetaRefs) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *DataplaneOverviewWithMetaRefs) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *DataplaneOverviewWithMetaRefs) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *DataplaneOverviewWithMetaRefs) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// DataplaneOverviewWithMetaReachableBackends - Reachable backend via transparent proxy when running with
// MeshExternalService, MeshService and MeshMultiZoneService. Setting an
// explicit list of refs can dramatically improve the performance of the
// mesh. If not specified, all services in the mesh are reachable.
type DataplaneOverviewWithMetaReachableBackends struct {
	Refs []DataplaneOverviewWithMetaRefs `json:"refs,omitempty"`
}

func (o *DataplaneOverviewWithMetaReachableBackends) GetRefs() []DataplaneOverviewWithMetaRefs {
	if o == nil {
		return nil
	}
	return o.Refs
}

// DataplaneOverviewWithMetaTransparentProxying - TransparentProxying describes the configuration for transparent proxying.
// It is used by default on Kubernetes.
type DataplaneOverviewWithMetaTransparentProxying struct {
	// List of services that will be accessed directly via IP:PORT
	// Use `*` to indicate direct access to every service in the Mesh.
	// Using `*` to directly access every service is a resource-intensive
	// operation, use it only if needed.
	DirectAccessServices []string `json:"directAccessServices,omitempty"`
	// The IP family mode to enable for. Can be "IPv4" or "DualStack".
	IPFamilyMode *DataplaneOverviewWithMetaIPFamilyMode `json:"ipFamilyMode,omitempty"`
	// Reachable backend via transparent proxy when running with
	// MeshExternalService, MeshService and MeshMultiZoneService. Setting an
	// explicit list of refs can dramatically improve the performance of the
	// mesh. If not specified, all services in the mesh are reachable.
	ReachableBackends *DataplaneOverviewWithMetaReachableBackends `json:"reachableBackends,omitempty"`
	// List of reachable services (represented by the value of
	// `kuma.io/service`) via transparent proxying. Setting an explicit list
	// can dramatically improve the performance of the mesh. If not specified,
	// all services in the mesh are reachable.
	ReachableServices []string `json:"reachableServices,omitempty"`
	// Port on which all inbound traffic is being transparently redirected.
	RedirectPortInbound *int64 `json:"redirectPortInbound,omitempty"`
	// Port on which all outbound traffic is being transparently redirected.
	RedirectPortOutbound *int64 `json:"redirectPortOutbound,omitempty"`
}

func (o *DataplaneOverviewWithMetaTransparentProxying) GetDirectAccessServices() []string {
	if o == nil {
		return nil
	}
	return o.DirectAccessServices
}

func (o *DataplaneOverviewWithMetaTransparentProxying) GetIPFamilyMode() *DataplaneOverviewWithMetaIPFamilyMode {
	if o == nil {
		return nil
	}
	return o.IPFamilyMode
}

func (o *DataplaneOverviewWithMetaTransparentProxying) GetReachableBackends() *DataplaneOverviewWithMetaReachableBackends {
	if o == nil {
		return nil
	}
	return o.ReachableBackends
}

func (o *DataplaneOverviewWithMetaTransparentProxying) GetReachableServices() []string {
	if o == nil {
		return nil
	}
	return o.ReachableServices
}

func (o *DataplaneOverviewWithMetaTransparentProxying) GetRedirectPortInbound() *int64 {
	if o == nil {
		return nil
	}
	return o.RedirectPortInbound
}

func (o *DataplaneOverviewWithMetaTransparentProxying) GetRedirectPortOutbound() *int64 {
	if o == nil {
		return nil
	}
	return o.RedirectPortOutbound
}

// DataplaneOverviewWithMetaNetworking - Networking describes inbound and outbound interfaces of the data plane
// proxy.
type DataplaneOverviewWithMetaNetworking struct {
	// IP on which the data plane proxy is accessible to the control plane and
	// other data plane proxies in the same network. This can also be a
	// hostname, in which case the control plane will periodically resolve it.
	Address *string `json:"address,omitempty"`
	// Admin describes configuration related to Envoy Admin API.
	// Due to security, all the Envoy Admin endpoints are exposed only on
	// localhost. Additionally, Envoy will expose `/ready` endpoint on
	// `networking.address` for health checking systems to be able to check the
	// state of Envoy. The rest of the endpoints exposed on `networking.address`
	// are always protected by mTLS and only meant to be consumed internally by
	// the control plane.
	Admin *DataplaneOverviewWithMetaAdmin `json:"admin,omitempty"`
	// In some situations, a data plane proxy resides in a private network (e.g.
	// Docker) and is not reachable via `address` to other data plane proxies.
	// `advertisedAddress` is configured with a routable address for such data
	// plane proxy so that other proxies in the mesh can connect to it over
	// `advertisedAddress` and not via address.
	//
	// Envoy still binds to the `address`, not `advertisedAddress`.
	AdvertisedAddress *string `json:"advertisedAddress,omitempty"`
	// Gateway describes a configuration of the gateway of the data plane proxy.
	Gateway *DataplaneOverviewWithMetaGateway `json:"gateway,omitempty"`
	// Inbound describes a list of inbound interfaces of the data plane proxy.
	//
	// Inbound describes a service implemented by the data plane proxy.
	// All incoming traffic to a data plane proxy is going through inbound
	// listeners. For every defined Inbound there is a corresponding Envoy
	// Listener.
	Inbound []DataplaneOverviewWithMetaInbound `json:"inbound,omitempty"`
	// Outbound describes a list of services consumed by the data plane proxy.
	// For every defined Outbound, there is a corresponding Envoy Listener.
	Outbound []DataplaneOverviewWithMetaOutbound `json:"outbound,omitempty"`
	// TransparentProxying describes the configuration for transparent proxying.
	// It is used by default on Kubernetes.
	TransparentProxying *DataplaneOverviewWithMetaTransparentProxying `json:"transparentProxying,omitempty"`
}

func (o *DataplaneOverviewWithMetaNetworking) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *DataplaneOverviewWithMetaNetworking) GetAdmin() *DataplaneOverviewWithMetaAdmin {
	if o == nil {
		return nil
	}
	return o.Admin
}

func (o *DataplaneOverviewWithMetaNetworking) GetAdvertisedAddress() *string {
	if o == nil {
		return nil
	}
	return o.AdvertisedAddress
}

func (o *DataplaneOverviewWithMetaNetworking) GetGateway() *DataplaneOverviewWithMetaGateway {
	if o == nil {
		return nil
	}
	return o.Gateway
}

func (o *DataplaneOverviewWithMetaNetworking) GetInbound() []DataplaneOverviewWithMetaInbound {
	if o == nil {
		return nil
	}
	return o.Inbound
}

func (o *DataplaneOverviewWithMetaNetworking) GetOutbound() []DataplaneOverviewWithMetaOutbound {
	if o == nil {
		return nil
	}
	return o.Outbound
}

func (o *DataplaneOverviewWithMetaNetworking) GetTransparentProxying() *DataplaneOverviewWithMetaTransparentProxying {
	if o == nil {
		return nil
	}
	return o.TransparentProxying
}

type DataplaneOverviewWithMetaEndpoints struct {
	// Inbound path is a path of the application from which we expose the
	// endpoint. It is recommended to be as specific as possible.
	InboundPath *string `json:"inboundPath,omitempty"`
	// Inbound port is a port of the application from which we expose the
	// endpoint.
	InboundPort *int64 `json:"inboundPort,omitempty"`
	// Path is a path on which we expose inbound path on the probes port.
	Path *string `json:"path,omitempty"`
}

func (o *DataplaneOverviewWithMetaEndpoints) GetInboundPath() *string {
	if o == nil {
		return nil
	}
	return o.InboundPath
}

func (o *DataplaneOverviewWithMetaEndpoints) GetInboundPort() *int64 {
	if o == nil {
		return nil
	}
	return o.InboundPort
}

func (o *DataplaneOverviewWithMetaEndpoints) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// DataplaneOverviewWithMetaProbes - Probes describe a list of endpoints that will be exposed without mTLS.
// This is useful to expose the health endpoints of the application so the
// orchestration system (e.g. Kubernetes) can still health check the
// application.
//
// See
// https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes
// for more information.
// Deprecated: this feature will be removed for Universal; on Kubernetes, it's
// not needed anymore.
type DataplaneOverviewWithMetaProbes struct {
	// List of endpoints to expose without mTLS.
	Endpoints []DataplaneOverviewWithMetaEndpoints `json:"endpoints,omitempty"`
	// Port on which the probe endpoints will be exposed. This cannot overlap
	// with any other ports.
	Port *int64 `json:"port,omitempty"`
}

func (o *DataplaneOverviewWithMetaProbes) GetEndpoints() []DataplaneOverviewWithMetaEndpoints {
	if o == nil {
		return nil
	}
	return o.Endpoints
}

func (o *DataplaneOverviewWithMetaProbes) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type Dataplane struct {
	// Configuration for metrics that should be collected and exposed by the
	// data plane proxy.
	//
	// Settings defined here will override their respective defaults
	// defined at a Mesh level.
	Metrics *DataplaneOverviewWithMetaMetrics `json:"metrics,omitempty"`
	// Networking describes inbound and outbound interfaces of the data plane
	// proxy.
	Networking *DataplaneOverviewWithMetaNetworking `json:"networking,omitempty"`
	// Probes describe a list of endpoints that will be exposed without mTLS.
	// This is useful to expose the health endpoints of the application so the
	// orchestration system (e.g. Kubernetes) can still health check the
	// application.
	//
	// See
	// https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes
	// for more information.
	// Deprecated: this feature will be removed for Universal; on Kubernetes, it's
	// not needed anymore.
	Probes *DataplaneOverviewWithMetaProbes `json:"probes,omitempty"`
}

func (o *Dataplane) GetMetrics() *DataplaneOverviewWithMetaMetrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

func (o *Dataplane) GetNetworking() *DataplaneOverviewWithMetaNetworking {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *Dataplane) GetProbes() *DataplaneOverviewWithMetaProbes {
	if o == nil {
		return nil
	}
	return o.Probes
}

// CertificateExpirationTime - Expiration time of the last certificate that was generated for a
// Dataplane.
type CertificateExpirationTime struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *CertificateExpirationTime) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *CertificateExpirationTime) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// LastCertificateRegeneration - Time on which the last certificate was generated.
type LastCertificateRegeneration struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *LastCertificateRegeneration) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *LastCertificateRegeneration) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// DataplaneOverviewWithMetaMTLS - Insights about mTLS for Dataplane.
type DataplaneOverviewWithMetaMTLS struct {
	// Expiration time of the last certificate that was generated for a
	// Dataplane.
	CertificateExpirationTime *CertificateExpirationTime `json:"certificateExpirationTime,omitempty"`
	// Number of certificate regenerations for a Dataplane.
	CertificateRegenerations *int64 `json:"certificateRegenerations,omitempty"`
	// Backend that was used to generate current certificate
	IssuedBackend *string `json:"issuedBackend,omitempty"`
	// Time on which the last certificate was generated.
	LastCertificateRegeneration *LastCertificateRegeneration `json:"lastCertificateRegeneration,omitempty"`
	// Supported backends (CA).
	SupportedBackends []string `json:"supportedBackends,omitempty"`
}

func (o *DataplaneOverviewWithMetaMTLS) GetCertificateExpirationTime() *CertificateExpirationTime {
	if o == nil {
		return nil
	}
	return o.CertificateExpirationTime
}

func (o *DataplaneOverviewWithMetaMTLS) GetCertificateRegenerations() *int64 {
	if o == nil {
		return nil
	}
	return o.CertificateRegenerations
}

func (o *DataplaneOverviewWithMetaMTLS) GetIssuedBackend() *string {
	if o == nil {
		return nil
	}
	return o.IssuedBackend
}

func (o *DataplaneOverviewWithMetaMTLS) GetLastCertificateRegeneration() *LastCertificateRegeneration {
	if o == nil {
		return nil
	}
	return o.LastCertificateRegeneration
}

func (o *DataplaneOverviewWithMetaMTLS) GetSupportedBackends() []string {
	if o == nil {
		return nil
	}
	return o.SupportedBackends
}

type Metadata struct {
}

// ConnectTime - Time when a given Dataplane connected to the Control Plane.
type ConnectTime struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *ConnectTime) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *ConnectTime) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// DisconnectTime - Time when a given Dataplane disconnected from the Control Plane.
type DisconnectTime struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *DisconnectTime) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *DisconnectTime) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// Cds - CDS defines all CDS stats.
type Cds struct {
	// Number of xDS responses ACKed by the Dataplane.
	ResponsesAcknowledged *int64 `json:"responsesAcknowledged,omitempty"`
	// Number of xDS responses NACKed by the Dataplane.
	ResponsesRejected *int64 `json:"responsesRejected,omitempty"`
	// Number of xDS responses sent to the Dataplane.
	ResponsesSent *int64 `json:"responsesSent,omitempty"`
}

func (o *Cds) GetResponsesAcknowledged() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesAcknowledged
}

func (o *Cds) GetResponsesRejected() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesRejected
}

func (o *Cds) GetResponsesSent() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesSent
}

// Eds - EDS defines all EDS stats.
type Eds struct {
	// Number of xDS responses ACKed by the Dataplane.
	ResponsesAcknowledged *int64 `json:"responsesAcknowledged,omitempty"`
	// Number of xDS responses NACKed by the Dataplane.
	ResponsesRejected *int64 `json:"responsesRejected,omitempty"`
	// Number of xDS responses sent to the Dataplane.
	ResponsesSent *int64 `json:"responsesSent,omitempty"`
}

func (o *Eds) GetResponsesAcknowledged() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesAcknowledged
}

func (o *Eds) GetResponsesRejected() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesRejected
}

func (o *Eds) GetResponsesSent() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesSent
}

// LastUpdateTime - Time when status of a given ADS subscription was most recently updated.
type LastUpdateTime struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *LastUpdateTime) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *LastUpdateTime) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// Lds - LDS defines all LDS stats.
type Lds struct {
	// Number of xDS responses ACKed by the Dataplane.
	ResponsesAcknowledged *int64 `json:"responsesAcknowledged,omitempty"`
	// Number of xDS responses NACKed by the Dataplane.
	ResponsesRejected *int64 `json:"responsesRejected,omitempty"`
	// Number of xDS responses sent to the Dataplane.
	ResponsesSent *int64 `json:"responsesSent,omitempty"`
}

func (o *Lds) GetResponsesAcknowledged() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesAcknowledged
}

func (o *Lds) GetResponsesRejected() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesRejected
}

func (o *Lds) GetResponsesSent() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesSent
}

// Rds - RDS defines all RDS stats.
type Rds struct {
	// Number of xDS responses ACKed by the Dataplane.
	ResponsesAcknowledged *int64 `json:"responsesAcknowledged,omitempty"`
	// Number of xDS responses NACKed by the Dataplane.
	ResponsesRejected *int64 `json:"responsesRejected,omitempty"`
	// Number of xDS responses sent to the Dataplane.
	ResponsesSent *int64 `json:"responsesSent,omitempty"`
}

func (o *Rds) GetResponsesAcknowledged() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesAcknowledged
}

func (o *Rds) GetResponsesRejected() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesRejected
}

func (o *Rds) GetResponsesSent() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesSent
}

// Total defines an aggregate over individual xDS stats.
type Total struct {
	// Number of xDS responses ACKed by the Dataplane.
	ResponsesAcknowledged *int64 `json:"responsesAcknowledged,omitempty"`
	// Number of xDS responses NACKed by the Dataplane.
	ResponsesRejected *int64 `json:"responsesRejected,omitempty"`
	// Number of xDS responses sent to the Dataplane.
	ResponsesSent *int64 `json:"responsesSent,omitempty"`
}

func (o *Total) GetResponsesAcknowledged() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesAcknowledged
}

func (o *Total) GetResponsesRejected() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesRejected
}

func (o *Total) GetResponsesSent() *int64 {
	if o == nil {
		return nil
	}
	return o.ResponsesSent
}

// DataplaneOverviewWithMetaStatus - Status of the ADS subscription.
type DataplaneOverviewWithMetaStatus struct {
	// CDS defines all CDS stats.
	Cds *Cds `json:"cds,omitempty"`
	// EDS defines all EDS stats.
	Eds *Eds `json:"eds,omitempty"`
	// Time when status of a given ADS subscription was most recently updated.
	LastUpdateTime *LastUpdateTime `json:"lastUpdateTime,omitempty"`
	// LDS defines all LDS stats.
	Lds *Lds `json:"lds,omitempty"`
	// RDS defines all RDS stats.
	Rds *Rds `json:"rds,omitempty"`
	// Total defines an aggregate over individual xDS stats.
	Total *Total `json:"total,omitempty"`
}

func (o *DataplaneOverviewWithMetaStatus) GetCds() *Cds {
	if o == nil {
		return nil
	}
	return o.Cds
}

func (o *DataplaneOverviewWithMetaStatus) GetEds() *Eds {
	if o == nil {
		return nil
	}
	return o.Eds
}

func (o *DataplaneOverviewWithMetaStatus) GetLastUpdateTime() *LastUpdateTime {
	if o == nil {
		return nil
	}
	return o.LastUpdateTime
}

func (o *DataplaneOverviewWithMetaStatus) GetLds() *Lds {
	if o == nil {
		return nil
	}
	return o.Lds
}

func (o *DataplaneOverviewWithMetaStatus) GetRds() *Rds {
	if o == nil {
		return nil
	}
	return o.Rds
}

func (o *DataplaneOverviewWithMetaStatus) GetTotal() *Total {
	if o == nil {
		return nil
	}
	return o.Total
}

// Envoy - Version of Envoy
type Envoy struct {
	// Full build tag of Envoy version
	Build *string `json:"build,omitempty"`
	// True iff Envoy version is compatible with Kuma DP version
	KumaDpCompatible *bool `json:"kumaDpCompatible,omitempty"`
	// Version number of Envoy
	Version *string `json:"version,omitempty"`
}

func (o *Envoy) GetBuild() *string {
	if o == nil {
		return nil
	}
	return o.Build
}

func (o *Envoy) GetKumaDpCompatible() *bool {
	if o == nil {
		return nil
	}
	return o.KumaDpCompatible
}

func (o *Envoy) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}

// KumaDp - Version of Kuma Dataplane
type KumaDp struct {
	// Build date of Kuma Dataplane version
	BuildDate *string `json:"buildDate,omitempty"`
	// Git commit of Kuma Dataplane version
	GitCommit *string `json:"gitCommit,omitempty"`
	// Git tag of Kuma Dataplane version
	GitTag *string `json:"gitTag,omitempty"`
	// True iff Kuma DP version is compatible with Kuma CP version
	KumaCpCompatible *bool `json:"kumaCpCompatible,omitempty"`
	// Version number of Kuma Dataplane
	Version *string `json:"version,omitempty"`
}

func (o *KumaDp) GetBuildDate() *string {
	if o == nil {
		return nil
	}
	return o.BuildDate
}

func (o *KumaDp) GetGitCommit() *string {
	if o == nil {
		return nil
	}
	return o.GitCommit
}

func (o *KumaDp) GetGitTag() *string {
	if o == nil {
		return nil
	}
	return o.GitTag
}

func (o *KumaDp) GetKumaCpCompatible() *bool {
	if o == nil {
		return nil
	}
	return o.KumaCpCompatible
}

func (o *KumaDp) GetVersion() *string {
	if o == nil {
		return nil
	}
	return o.Version
}

// Version of Envoy and Kuma dataplane
type Version struct {
	// Versions of other dependencies, i.e. CoreDNS
	Dependencies map[string]string `json:"dependencies,omitempty"`
	// Version of Envoy
	Envoy *Envoy `json:"envoy,omitempty"`
	// Version of Kuma Dataplane
	KumaDp *KumaDp `json:"kumaDp,omitempty"`
}

func (o *Version) GetDependencies() map[string]string {
	if o == nil {
		return nil
	}
	return o.Dependencies
}

func (o *Version) GetEnvoy() *Envoy {
	if o == nil {
		return nil
	}
	return o.Envoy
}

func (o *Version) GetKumaDp() *KumaDp {
	if o == nil {
		return nil
	}
	return o.KumaDp
}

// Subscriptions - DiscoverySubscription describes a single ADS subscription created by a Dataplane to the Control Plane.
type Subscriptions struct {
	// Time when a given Dataplane connected to the Control Plane.
	ConnectTime *ConnectTime `json:"connectTime,omitempty"`
	// Control Plane instance that handled given subscription.
	ControlPlaneInstanceID *string `json:"controlPlaneInstanceId,omitempty"`
	// Time when a given Dataplane disconnected from the Control Plane.
	DisconnectTime *DisconnectTime `json:"disconnectTime,omitempty"`
	// Generation is an integer number which is periodically increased by the
	// status sink
	Generation *int64 `json:"generation,omitempty"`
	// Unique id per ADS subscription.
	ID *string `json:"id,omitempty"`
	// Status of the ADS subscription.
	Status *DataplaneOverviewWithMetaStatus `json:"status,omitempty"`
	// Version of Envoy and Kuma dataplane
	Version *Version `json:"version,omitempty"`
}

func (o *Subscriptions) GetConnectTime() *ConnectTime {
	if o == nil {
		return nil
	}
	return o.ConnectTime
}

func (o *Subscriptions) GetControlPlaneInstanceID() *string {
	if o == nil {
		return nil
	}
	return o.ControlPlaneInstanceID
}

func (o *Subscriptions) GetDisconnectTime() *DisconnectTime {
	if o == nil {
		return nil
	}
	return o.DisconnectTime
}

func (o *Subscriptions) GetGeneration() *int64 {
	if o == nil {
		return nil
	}
	return o.Generation
}

func (o *Subscriptions) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Subscriptions) GetStatus() *DataplaneOverviewWithMetaStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Subscriptions) GetVersion() *Version {
	if o == nil {
		return nil
	}
	return o.Version
}

type DataplaneInsight struct {
	// Insights about mTLS for Dataplane.
	MTLS     *DataplaneOverviewWithMetaMTLS `json:"mTLS,omitempty"`
	Metadata *Metadata                      `json:"metadata,omitempty"`
	// List of ADS subscriptions created by a given Dataplane.
	Subscriptions []Subscriptions `json:"subscriptions,omitempty"`
}

func (o *DataplaneInsight) GetMTLS() *DataplaneOverviewWithMetaMTLS {
	if o == nil {
		return nil
	}
	return o.MTLS
}

func (o *DataplaneInsight) GetMetadata() *Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *DataplaneInsight) GetSubscriptions() []Subscriptions {
	if o == nil {
		return nil
	}
	return o.Subscriptions
}

type DataplaneOverviewWithMeta struct {
	// the type of this resource
	Type string `json:"type"`
	// the mesh this resource is part of
	Mesh string `json:"mesh"`
	// the name of the resource
	Name string `json:"name"`
	// the label of the resource
	Labels           map[string]string `json:"labels"`
	Dataplane        *Dataplane        `json:"dataplane,omitempty"`
	DataplaneInsight *DataplaneInsight `json:"dataplaneInsight,omitempty"`
}

func (o *DataplaneOverviewWithMeta) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *DataplaneOverviewWithMeta) GetMesh() string {
	if o == nil {
		return ""
	}
	return o.Mesh
}

func (o *DataplaneOverviewWithMeta) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DataplaneOverviewWithMeta) GetLabels() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Labels
}

func (o *DataplaneOverviewWithMeta) GetDataplane() *Dataplane {
	if o == nil {
		return nil
	}
	return o.Dataplane
}

func (o *DataplaneOverviewWithMeta) GetDataplaneInsight() *DataplaneInsight {
	if o == nil {
		return nil
	}
	return o.DataplaneInsight
}
