// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
)

// Aggregate - PrometheusAggregateMetricsConfig defines endpoints that should be scrapped by kuma-dp for prometheus metrics.
type Aggregate struct {
	// Address on which a service expose HTTP endpoint with Prometheus metrics.
	Address *string `json:"address,omitempty"`
	// If false then the application won't be scrapped. If nil, then it is treated
	// as true and kuma-dp scrapes metrics from the service.
	Enabled *bool `json:"enabled,omitempty"`
	// Name which identify given configuration.
	Name *string `json:"name,omitempty"`
	// Path on which a service expose HTTP endpoint with Prometheus metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a service expose HTTP endpoint with Prometheus metrics.
	Port *int64 `json:"port,omitempty"`
}

func (o *Aggregate) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *Aggregate) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *Aggregate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Aggregate) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *Aggregate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// ConfEnvoy - Configuration of Envoy's metrics.
type ConfEnvoy struct {
	// FilterRegex value that is going to be passed to Envoy for filtering
	// Envoy metrics.
	FilterRegex *string `json:"filterRegex,omitempty"`
	// If true then return metrics that Envoy has updated (counters incremented
	// at least once, gauges changed at least once, and histograms added to at
	// least once). If nil, then it is treated as false.
	UsedOnly *bool `json:"usedOnly,omitempty"`
}

func (o *ConfEnvoy) GetFilterRegex() *string {
	if o == nil {
		return nil
	}
	return o.FilterRegex
}

func (o *ConfEnvoy) GetUsedOnly() *bool {
	if o == nil {
		return nil
	}
	return o.UsedOnly
}

type ConfModeType string

const (
	ConfModeTypeStr     ConfModeType = "str"
	ConfModeTypeInteger ConfModeType = "integer"
)

// ConfMode - mode defines how configured is the TLS for Prometheus.
// Supported values, delegated, disabled, activeMTLSBackend. Default to
// `activeMTLSBackend`.
type ConfMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type ConfModeType
}

func CreateConfModeStr(str string) ConfMode {
	typ := ConfModeTypeStr

	return ConfMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateConfModeInteger(integer int64) ConfMode {
	typ := ConfModeTypeInteger

	return ConfMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *ConfMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ConfModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = ConfModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfMode", string(data))
}

func (u ConfMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type ConfMode: all fields are null")
}

// ConfTLS - Configuration of TLS for prometheus listener.
type ConfTLS struct {
	// mode defines how configured is the TLS for Prometheus.
	// Supported values, delegated, disabled, activeMTLSBackend. Default to
	// `activeMTLSBackend`.
	Mode *ConfMode `json:"mode,omitempty"`
}

func (o *ConfTLS) GetMode() *ConfMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

type PrometheusMetricsBackendConfig struct {
	// Map with the configuration of applications which metrics are going to be
	// scrapped by kuma-dp.
	Aggregate []Aggregate `json:"aggregate,omitempty"`
	// Configuration of Envoy's metrics.
	Envoy *ConfEnvoy `json:"envoy,omitempty"`
	// Path on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Port *int64 `json:"port,omitempty"`
	// If true then endpoints for scraping metrics won't require mTLS even if mTLS
	// is enabled in Mesh. If nil, then it is treated as false.
	SkipMTLS *bool `json:"skipMTLS,omitempty"`
	// Tags associated with an application this dataplane is deployed next to,
	// e.g. service=web, version=1.0.
	// `service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Configuration of TLS for prometheus listener.
	TLS *ConfTLS `json:"tls,omitempty"`
}

func (o *PrometheusMetricsBackendConfig) GetAggregate() []Aggregate {
	if o == nil {
		return nil
	}
	return o.Aggregate
}

func (o *PrometheusMetricsBackendConfig) GetEnvoy() *ConfEnvoy {
	if o == nil {
		return nil
	}
	return o.Envoy
}

func (o *PrometheusMetricsBackendConfig) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *PrometheusMetricsBackendConfig) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *PrometheusMetricsBackendConfig) GetSkipMTLS() *bool {
	if o == nil {
		return nil
	}
	return o.SkipMTLS
}

func (o *PrometheusMetricsBackendConfig) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *PrometheusMetricsBackendConfig) GetTLS() *ConfTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

type DataplaneItemConfType string

const (
	DataplaneItemConfTypePrometheusMetricsBackendConfig DataplaneItemConfType = "PrometheusMetricsBackendConfig"
)

type DataplaneItemConf struct {
	PrometheusMetricsBackendConfig *PrometheusMetricsBackendConfig `queryParam:"inline"`

	Type DataplaneItemConfType
}

func CreateDataplaneItemConfPrometheusMetricsBackendConfig(prometheusMetricsBackendConfig PrometheusMetricsBackendConfig) DataplaneItemConf {
	typ := DataplaneItemConfTypePrometheusMetricsBackendConfig

	return DataplaneItemConf{
		PrometheusMetricsBackendConfig: &prometheusMetricsBackendConfig,
		Type:                           typ,
	}
}

func (u *DataplaneItemConf) UnmarshalJSON(data []byte) error {

	var prometheusMetricsBackendConfig PrometheusMetricsBackendConfig = PrometheusMetricsBackendConfig{}
	if err := utils.UnmarshalJSON(data, &prometheusMetricsBackendConfig, "", true, true); err == nil {
		u.PrometheusMetricsBackendConfig = &prometheusMetricsBackendConfig
		u.Type = DataplaneItemConfTypePrometheusMetricsBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneItemConf", string(data))
}

func (u DataplaneItemConf) MarshalJSON() ([]byte, error) {
	if u.PrometheusMetricsBackendConfig != nil {
		return utils.MarshalJSON(u.PrometheusMetricsBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneItemConf: all fields are null")
}

// Metrics - Configuration for metrics that should be collected and exposed by the
// data plane proxy.
//
// Settings defined here will override their respective defaults
// defined at a Mesh level.
type Metrics struct {
	Conf *DataplaneItemConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.metrics.enabledBackend
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'prometheus')
	Type *string `json:"type,omitempty"`
}

func (o *Metrics) GetConf() *DataplaneItemConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *Metrics) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Metrics) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Admin describes configuration related to Envoy Admin API.
// Due to security, all the Envoy Admin endpoints are exposed only on
// localhost. Additionally, Envoy will expose `/ready` endpoint on
// `networking.address` for health checking systems to be able to check the
// state of Envoy. The rest of the endpoints exposed on `networking.address`
// are always protected by mTLS and only meant to be consumed internally by
// the control plane.
type Admin struct {
	// Port on which Envoy Admin API server will be listening
	Port *int64 `json:"port,omitempty"`
}

func (o *Admin) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

type DataplaneItemTypeType string

const (
	DataplaneItemTypeTypeStr     DataplaneItemTypeType = "str"
	DataplaneItemTypeTypeInteger DataplaneItemTypeType = "integer"
)

// DataplaneItemType - Type of gateway this data plane proxy manages.
// There are two types: `DELEGATED` and `BUILTIN`. Defaults to
// `DELEGATED`.
//
// A `DELEGATED` gateway is an independently deployed proxy (e.g., Kong,
// Contour, etc) that receives inbound traffic that is not proxied by
// Kuma, and it sends outbound traffic into the data plane proxy.
//
// The `BUILTIN` gateway type causes the data plane proxy itself to be
// configured as a gateway.
//
// See https://kuma.io/docs/latest/explore/gateway/ for more information.
type DataplaneItemType struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type DataplaneItemTypeType
}

func CreateDataplaneItemTypeStr(str string) DataplaneItemType {
	typ := DataplaneItemTypeTypeStr

	return DataplaneItemType{
		Str:  &str,
		Type: typ,
	}
}

func CreateDataplaneItemTypeInteger(integer int64) DataplaneItemType {
	typ := DataplaneItemTypeTypeInteger

	return DataplaneItemType{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *DataplaneItemType) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = DataplaneItemTypeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = DataplaneItemTypeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneItemType", string(data))
}

func (u DataplaneItemType) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneItemType: all fields are null")
}

// Gateway describes a configuration of the gateway of the data plane proxy.
type Gateway struct {
	// Tags associated with a gateway of this data plane to, e.g.
	// `kuma.io/service=gateway`, `env=prod`. `kuma.io/service` tag is
	// mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Type of gateway this data plane proxy manages.
	// There are two types: `DELEGATED` and `BUILTIN`. Defaults to
	// `DELEGATED`.
	//
	// A `DELEGATED` gateway is an independently deployed proxy (e.g., Kong,
	// Contour, etc) that receives inbound traffic that is not proxied by
	// Kuma, and it sends outbound traffic into the data plane proxy.
	//
	// The `BUILTIN` gateway type causes the data plane proxy itself to be
	// configured as a gateway.
	//
	// See https://kuma.io/docs/latest/explore/gateway/ for more information.
	Type *DataplaneItemType `json:"type,omitempty"`
}

func (o *Gateway) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *Gateway) GetType() *DataplaneItemType {
	if o == nil {
		return nil
	}
	return o.Type
}

// Health describes the status of an inbound.
// If 'health' is nil we consider data plane proxy as healthy.
// Unhealthy data plane proxies are excluded from Endpoints Discovery
// Service (EDS). On Kubernetes, it is filled automatically by the control
// plane if Pod has readiness probe configured. On Universal, it can be
// set by the external health checking system, but the most common way is
// to use service probes.
//
// See https://kuma.io/docs/latest/documentation/health for more
// information.
type Health struct {
	// Ready indicates if the data plane proxy is ready to serve the
	// traffic.
	Ready *bool `json:"ready,omitempty"`
}

func (o *Health) GetReady() *bool {
	if o == nil {
		return nil
	}
	return o.Ready
}

// Interval between consecutive health checks.
type Interval struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *Interval) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *Interval) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// DataplaneItemTCP - Tcp checker tries to establish tcp connection with destination
type DataplaneItemTCP struct {
}

// Timeout - Maximum time to wait for a health check response.
type Timeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *Timeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *Timeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// ServiceProbe defines parameters for probing the service next to
// sidecar. When service probe is defined, Envoy will periodically health
// check the application next to it and report the status to the control
// plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so
// this is not used.
//
// See https://kuma.io/docs/latest/documentation/health for more
// information.
type ServiceProbe struct {
	// Number of consecutive healthy checks before considering a host
	// healthy.
	HealthyThreshold *int64 `json:"healthyThreshold,omitempty"`
	// Interval between consecutive health checks.
	Interval *Interval `json:"interval,omitempty"`
	// Tcp checker tries to establish tcp connection with destination
	TCP *DataplaneItemTCP `json:"tcp,omitempty"`
	// Maximum time to wait for a health check response.
	Timeout *Timeout `json:"timeout,omitempty"`
	// Number of consecutive unhealthy checks before considering a host
	// unhealthy.
	UnhealthyThreshold *int64 `json:"unhealthyThreshold,omitempty"`
}

func (o *ServiceProbe) GetHealthyThreshold() *int64 {
	if o == nil {
		return nil
	}
	return o.HealthyThreshold
}

func (o *ServiceProbe) GetInterval() *Interval {
	if o == nil {
		return nil
	}
	return o.Interval
}

func (o *ServiceProbe) GetTCP() *DataplaneItemTCP {
	if o == nil {
		return nil
	}
	return o.TCP
}

func (o *ServiceProbe) GetTimeout() *Timeout {
	if o == nil {
		return nil
	}
	return o.Timeout
}

func (o *ServiceProbe) GetUnhealthyThreshold() *int64 {
	if o == nil {
		return nil
	}
	return o.UnhealthyThreshold
}

type DataplaneItemStateType string

const (
	DataplaneItemStateTypeStr     DataplaneItemStateType = "str"
	DataplaneItemStateTypeInteger DataplaneItemStateType = "integer"
)

// DataplaneItemState - State describes the current state of the listener.
type DataplaneItemState struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type DataplaneItemStateType
}

func CreateDataplaneItemStateStr(str string) DataplaneItemState {
	typ := DataplaneItemStateTypeStr

	return DataplaneItemState{
		Str:  &str,
		Type: typ,
	}
}

func CreateDataplaneItemStateInteger(integer int64) DataplaneItemState {
	typ := DataplaneItemStateTypeInteger

	return DataplaneItemState{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *DataplaneItemState) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = DataplaneItemStateTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = DataplaneItemStateTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataplaneItemState", string(data))
}

func (u DataplaneItemState) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type DataplaneItemState: all fields are null")
}

// DataplaneItemInbound - Inbound describes a service implemented by the data plane proxy.
type DataplaneItemInbound struct {
	// Address on which inbound listener will be exposed.
	// Defaults to `networking.address`.
	Address *string `json:"address,omitempty"`
	// Health describes the status of an inbound.
	// If 'health' is nil we consider data plane proxy as healthy.
	// Unhealthy data plane proxies are excluded from Endpoints Discovery
	// Service (EDS). On Kubernetes, it is filled automatically by the control
	// plane if Pod has readiness probe configured. On Universal, it can be
	// set by the external health checking system, but the most common way is
	// to use service probes.
	//
	// See https://kuma.io/docs/latest/documentation/health for more
	// information.
	Health *Health `json:"health,omitempty"`
	// Name adds another way of referencing this port, usable with MeshService
	Name *string `json:"name,omitempty"`
	// Port of the inbound interface that will forward requests to the
	// service.
	//
	// When transparent proxying is used, it is a port on which the service is
	// listening to. When transparent proxying is not used, Envoy will bind to
	// this port.
	Port *int64 `json:"port,omitempty"`
	// Address of the service that requests will be forwarded to.
	// Defaults to 'inbound.address', since Kuma DP should be deployed next
	// to the service.
	ServiceAddress *string `json:"serviceAddress,omitempty"`
	// Port of the service that requests will be forwarded to.
	// Defaults to the same value as `port`.
	ServicePort *int64 `json:"servicePort,omitempty"`
	// ServiceProbe defines parameters for probing the service next to
	// sidecar. When service probe is defined, Envoy will periodically health
	// check the application next to it and report the status to the control
	// plane. On Kubernetes, Kuma deployments rely on Kubernetes probes so
	// this is not used.
	//
	// See https://kuma.io/docs/latest/documentation/health for more
	// information.
	ServiceProbe *ServiceProbe `json:"serviceProbe,omitempty"`
	// State describes the current state of the listener.
	State *DataplaneItemState `json:"state,omitempty"`
	// Tags associated with an application this data plane proxy is deployed
	// next to, e.g. `kuma.io/service=web`, `version=1.0`. You can then
	// reference these tags in policies like MeshTrafficPermission.
	// `kuma.io/service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *DataplaneItemInbound) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *DataplaneItemInbound) GetHealth() *Health {
	if o == nil {
		return nil
	}
	return o.Health
}

func (o *DataplaneItemInbound) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *DataplaneItemInbound) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DataplaneItemInbound) GetServiceAddress() *string {
	if o == nil {
		return nil
	}
	return o.ServiceAddress
}

func (o *DataplaneItemInbound) GetServicePort() *int64 {
	if o == nil {
		return nil
	}
	return o.ServicePort
}

func (o *DataplaneItemInbound) GetServiceProbe() *ServiceProbe {
	if o == nil {
		return nil
	}
	return o.ServiceProbe
}

func (o *DataplaneItemInbound) GetState() *DataplaneItemState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *DataplaneItemInbound) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// BackendRef is a way to target MeshService.
// Experimental. Do not use on production yet.
type BackendRef struct {
	// Kind is a type of the object to target. Allowed: MeshService
	Kind *string `json:"kind,omitempty"`
	// Labels to select a single object.
	// If no object is selected then outbound is not created.
	// If multiple objects are selected then the oldest one is used.
	Labels map[string]string `json:"labels,omitempty"`
	// Name of the targeted object
	Name *string `json:"name,omitempty"`
	// Port of the targeted object. Required when kind is MeshService.
	Port *int64 `json:"port,omitempty"`
}

func (o *BackendRef) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *BackendRef) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *BackendRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *BackendRef) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// Outbound describes a service consumed by the data plane proxy.
type Outbound struct {
	// IP on which the consumed service will be available to this data plane
	// proxy. On Kubernetes, it's usually ClusterIP of a Service or PodIP of a
	// Headless Service. Defaults to 127.0.0.1
	Address *string `json:"address,omitempty"`
	// BackendRef is a way to target MeshService.
	// Experimental. Do not use on production yet.
	BackendRef *BackendRef `json:"backendRef,omitempty"`
	// Port on which the consumed service will be available to this data plane
	// proxy. When transparent proxying is not used, Envoy will bind to this
	// port.
	Port *int64 `json:"port,omitempty"`
	// Tags of consumed data plane proxies.
	// `kuma.io/service` tag is required.
	// These tags can then be referenced in `destinations` section of policies
	// like TrafficRoute or in `to` section in policies like MeshAccessLog. It
	// is recommended to only use `kuma.io/service`. If you need to consume
	// specific data plane proxy of a service (for example: `version=v2`) the
	// better practice is to use TrafficRoute.
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Outbound) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *Outbound) GetBackendRef() *BackendRef {
	if o == nil {
		return nil
	}
	return o.BackendRef
}

func (o *Outbound) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *Outbound) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type IPFamilyModeType string

const (
	IPFamilyModeTypeStr     IPFamilyModeType = "str"
	IPFamilyModeTypeInteger IPFamilyModeType = "integer"
)

// IPFamilyMode - The IP family mode to enable for. Can be "IPv4" or "DualStack".
type IPFamilyMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type IPFamilyModeType
}

func CreateIPFamilyModeStr(str string) IPFamilyMode {
	typ := IPFamilyModeTypeStr

	return IPFamilyMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateIPFamilyModeInteger(integer int64) IPFamilyMode {
	typ := IPFamilyModeTypeInteger

	return IPFamilyMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *IPFamilyMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = IPFamilyModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = IPFamilyModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for IPFamilyMode", string(data))
}

func (u IPFamilyMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type IPFamilyMode: all fields are null")
}

type Refs struct {
	// Type of the backend: MeshService or MeshExternalService
	//
	// 	+required
	Kind *string `json:"kind,omitempty"`
	// Labels used to select backends
	//
	// 	+optional
	Labels map[string]string `json:"labels,omitempty"`
	// Name of the backend.
	//
	// 	+optional
	Name *string `json:"name,omitempty"`
	// Namespace of the backend. Might be empty
	//
	// 	+optional
	Namespace *string `json:"namespace,omitempty"`
	// Port of the backend.
	//
	// 	+optional
	Port *int64 `json:"port,omitempty"`
}

func (o *Refs) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *Refs) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *Refs) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Refs) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *Refs) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// ReachableBackends - Reachable backend via transparent proxy when running with
// MeshExternalService, MeshService and MeshMultiZoneService. Setting an
// explicit list of refs can dramatically improve the performance of the
// mesh. If not specified, all services in the mesh are reachable.
type ReachableBackends struct {
	Refs []Refs `json:"refs,omitempty"`
}

func (o *ReachableBackends) GetRefs() []Refs {
	if o == nil {
		return nil
	}
	return o.Refs
}

// TransparentProxying describes the configuration for transparent proxying.
// It is used by default on Kubernetes.
type TransparentProxying struct {
	// List of services that will be accessed directly via IP:PORT
	// Use `*` to indicate direct access to every service in the Mesh.
	// Using `*` to directly access every service is a resource-intensive
	// operation, use it only if needed.
	DirectAccessServices []string `json:"directAccessServices,omitempty"`
	// The IP family mode to enable for. Can be "IPv4" or "DualStack".
	IPFamilyMode *IPFamilyMode `json:"ipFamilyMode,omitempty"`
	// Reachable backend via transparent proxy when running with
	// MeshExternalService, MeshService and MeshMultiZoneService. Setting an
	// explicit list of refs can dramatically improve the performance of the
	// mesh. If not specified, all services in the mesh are reachable.
	ReachableBackends *ReachableBackends `json:"reachableBackends,omitempty"`
	// List of reachable services (represented by the value of
	// `kuma.io/service`) via transparent proxying. Setting an explicit list
	// can dramatically improve the performance of the mesh. If not specified,
	// all services in the mesh are reachable.
	ReachableServices []string `json:"reachableServices,omitempty"`
	// Port on which all inbound traffic is being transparently redirected.
	RedirectPortInbound *int64 `json:"redirectPortInbound,omitempty"`
	// Port on which all outbound traffic is being transparently redirected.
	RedirectPortOutbound *int64 `json:"redirectPortOutbound,omitempty"`
}

func (o *TransparentProxying) GetDirectAccessServices() []string {
	if o == nil {
		return nil
	}
	return o.DirectAccessServices
}

func (o *TransparentProxying) GetIPFamilyMode() *IPFamilyMode {
	if o == nil {
		return nil
	}
	return o.IPFamilyMode
}

func (o *TransparentProxying) GetReachableBackends() *ReachableBackends {
	if o == nil {
		return nil
	}
	return o.ReachableBackends
}

func (o *TransparentProxying) GetReachableServices() []string {
	if o == nil {
		return nil
	}
	return o.ReachableServices
}

func (o *TransparentProxying) GetRedirectPortInbound() *int64 {
	if o == nil {
		return nil
	}
	return o.RedirectPortInbound
}

func (o *TransparentProxying) GetRedirectPortOutbound() *int64 {
	if o == nil {
		return nil
	}
	return o.RedirectPortOutbound
}

// Networking describes inbound and outbound interfaces of the data plane
// proxy.
type Networking struct {
	// IP on which the data plane proxy is accessible to the control plane and
	// other data plane proxies in the same network. This can also be a
	// hostname, in which case the control plane will periodically resolve it.
	Address *string `json:"address,omitempty"`
	// Admin describes configuration related to Envoy Admin API.
	// Due to security, all the Envoy Admin endpoints are exposed only on
	// localhost. Additionally, Envoy will expose `/ready` endpoint on
	// `networking.address` for health checking systems to be able to check the
	// state of Envoy. The rest of the endpoints exposed on `networking.address`
	// are always protected by mTLS and only meant to be consumed internally by
	// the control plane.
	Admin *Admin `json:"admin,omitempty"`
	// In some situations, a data plane proxy resides in a private network (e.g.
	// Docker) and is not reachable via `address` to other data plane proxies.
	// `advertisedAddress` is configured with a routable address for such data
	// plane proxy so that other proxies in the mesh can connect to it over
	// `advertisedAddress` and not via address.
	//
	// Envoy still binds to the `address`, not `advertisedAddress`.
	AdvertisedAddress *string `json:"advertisedAddress,omitempty"`
	// Gateway describes a configuration of the gateway of the data plane proxy.
	Gateway *Gateway `json:"gateway,omitempty"`
	// Inbound describes a list of inbound interfaces of the data plane proxy.
	//
	// Inbound describes a service implemented by the data plane proxy.
	// All incoming traffic to a data plane proxy is going through inbound
	// listeners. For every defined Inbound there is a corresponding Envoy
	// Listener.
	Inbound []DataplaneItemInbound `json:"inbound,omitempty"`
	// Outbound describes a list of services consumed by the data plane proxy.
	// For every defined Outbound, there is a corresponding Envoy Listener.
	Outbound []Outbound `json:"outbound,omitempty"`
	// TransparentProxying describes the configuration for transparent proxying.
	// It is used by default on Kubernetes.
	TransparentProxying *TransparentProxying `json:"transparentProxying,omitempty"`
}

func (o *Networking) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *Networking) GetAdmin() *Admin {
	if o == nil {
		return nil
	}
	return o.Admin
}

func (o *Networking) GetAdvertisedAddress() *string {
	if o == nil {
		return nil
	}
	return o.AdvertisedAddress
}

func (o *Networking) GetGateway() *Gateway {
	if o == nil {
		return nil
	}
	return o.Gateway
}

func (o *Networking) GetInbound() []DataplaneItemInbound {
	if o == nil {
		return nil
	}
	return o.Inbound
}

func (o *Networking) GetOutbound() []Outbound {
	if o == nil {
		return nil
	}
	return o.Outbound
}

func (o *Networking) GetTransparentProxying() *TransparentProxying {
	if o == nil {
		return nil
	}
	return o.TransparentProxying
}

type Endpoints struct {
	// Inbound path is a path of the application from which we expose the
	// endpoint. It is recommended to be as specific as possible.
	InboundPath *string `json:"inboundPath,omitempty"`
	// Inbound port is a port of the application from which we expose the
	// endpoint.
	InboundPort *int64 `json:"inboundPort,omitempty"`
	// Path is a path on which we expose inbound path on the probes port.
	Path *string `json:"path,omitempty"`
}

func (o *Endpoints) GetInboundPath() *string {
	if o == nil {
		return nil
	}
	return o.InboundPath
}

func (o *Endpoints) GetInboundPort() *int64 {
	if o == nil {
		return nil
	}
	return o.InboundPort
}

func (o *Endpoints) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Probes describe a list of endpoints that will be exposed without mTLS.
// This is useful to expose the health endpoints of the application so the
// orchestration system (e.g. Kubernetes) can still health check the
// application.
//
// See
// https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes
// for more information.
// Deprecated: this feature will be removed for Universal; on Kubernetes, it's
// not needed anymore.
type Probes struct {
	// List of endpoints to expose without mTLS.
	Endpoints []Endpoints `json:"endpoints,omitempty"`
	// Port on which the probe endpoints will be exposed. This cannot overlap
	// with any other ports.
	Port *int64 `json:"port,omitempty"`
}

func (o *Probes) GetEndpoints() []Endpoints {
	if o == nil {
		return nil
	}
	return o.Endpoints
}

func (o *Probes) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// DataplaneItem - Successful response
type DataplaneItem struct {
	Labels map[string]string `json:"labels,omitempty"`
	Mesh   string            `json:"mesh"`
	// Configuration for metrics that should be collected and exposed by the
	// data plane proxy.
	//
	// Settings defined here will override their respective defaults
	// defined at a Mesh level.
	Metrics *Metrics `json:"metrics,omitempty"`
	Name    string   `json:"name"`
	// Networking describes inbound and outbound interfaces of the data plane
	// proxy.
	Networking *Networking `json:"networking,omitempty"`
	// Probes describe a list of endpoints that will be exposed without mTLS.
	// This is useful to expose the health endpoints of the application so the
	// orchestration system (e.g. Kubernetes) can still health check the
	// application.
	//
	// See
	// https://kuma.io/docs/latest/policies/service-health-probes/#virtual-probes
	// for more information.
	// Deprecated: this feature will be removed for Universal; on Kubernetes, it's
	// not needed anymore.
	Probes *Probes `json:"probes,omitempty"`
	Type   string  `json:"type"`
}

func (o *DataplaneItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *DataplaneItem) GetMesh() string {
	if o == nil {
		return ""
	}
	return o.Mesh
}

func (o *DataplaneItem) GetMetrics() *Metrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

func (o *DataplaneItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DataplaneItem) GetNetworking() *Networking {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *DataplaneItem) GetProbes() *Probes {
	if o == nil {
		return nil
	}
	return o.Probes
}

func (o *DataplaneItem) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}
