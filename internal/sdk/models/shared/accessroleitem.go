// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-kong-mesh/internal/sdk/internal/utils"
)

type AccessRoleItemAccessType string

const (
	AccessRoleItemAccessTypeStr     AccessRoleItemAccessType = "str"
	AccessRoleItemAccessTypeInteger AccessRoleItemAccessType = "integer"
)

type AccessRoleItemAccess struct {
	Str     *string `queryParam:"inline,name=access"`
	Integer *int64  `queryParam:"inline,name=access"`

	Type AccessRoleItemAccessType
}

func CreateAccessRoleItemAccessStr(str string) AccessRoleItemAccess {
	typ := AccessRoleItemAccessTypeStr

	return AccessRoleItemAccess{
		Str:  &str,
		Type: typ,
	}
}

func CreateAccessRoleItemAccessInteger(integer int64) AccessRoleItemAccess {
	typ := AccessRoleItemAccessTypeInteger

	return AccessRoleItemAccess{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *AccessRoleItemAccess) UnmarshalJSON(data []byte) error {

	var candidates []utils.UnionCandidate

	// Collect all valid candidates
	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessRoleItemAccessTypeStr,
			Value: &str,
		})
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		candidates = append(candidates, utils.UnionCandidate{
			Type:  AccessRoleItemAccessTypeInteger,
			Value: &integer,
		})
	}

	if len(candidates) == 0 {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessRoleItemAccess", string(data))
	}

	// Pick the best candidate using multi-stage filtering
	best := utils.PickBestCandidate(candidates)
	if best == nil {
		return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessRoleItemAccess", string(data))
	}

	// Set the union type and value based on the best candidate
	u.Type = best.Type.(AccessRoleItemAccessType)
	switch best.Type {
	case AccessRoleItemAccessTypeStr:
		u.Str = best.Value.(*string)
		return nil
	case AccessRoleItemAccessTypeInteger:
		u.Integer = best.Value.(*int64)
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessRoleItemAccess", string(data))
}

func (u AccessRoleItemAccess) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type AccessRoleItemAccess: all fields are null")
}

type Destinations struct {
	// Tags to match, can be used for both source and destinations
	Match map[string]string `json:"match,omitempty"`
}

func (d *Destinations) GetMatch() map[string]string {
	if d == nil {
		return nil
	}
	return d.Match
}

type AccessRoleItemTags struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

func (a *AccessRoleItemTags) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AccessRoleItemTags) GetValue() *string {
	if a == nil {
		return nil
	}
	return a.Value
}

type DpToken struct {
	Tags []AccessRoleItemTags `json:"tags"`
}

func (d *DpToken) GetTags() []AccessRoleItemTags {
	if d == nil {
		return nil
	}
	return d.Tags
}

type AccessRoleItemRulesTargetRef struct {
	Kind *string           `json:"kind,omitempty"`
	Mesh *string           `json:"mesh,omitempty"`
	Name *string           `json:"name,omitempty"`
	Tags map[string]string `json:"tags,omitempty"`
}

func (a *AccessRoleItemRulesTargetRef) GetKind() *string {
	if a == nil {
		return nil
	}
	return a.Kind
}

func (a *AccessRoleItemRulesTargetRef) GetMesh() *string {
	if a == nil {
		return nil
	}
	return a.Mesh
}

func (a *AccessRoleItemRulesTargetRef) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AccessRoleItemRulesTargetRef) GetTags() map[string]string {
	if a == nil {
		return nil
	}
	return a.Tags
}

type AccessRoleItemFrom struct {
	TargetRef *AccessRoleItemRulesTargetRef `json:"targetRef,omitempty"`
}

func (a *AccessRoleItemFrom) GetTargetRef() *AccessRoleItemRulesTargetRef {
	if a == nil {
		return nil
	}
	return a.TargetRef
}

type AccessRoleItemSelectors struct {
	// Tags to match, can be used for both source and destinations
	Match map[string]string `json:"match,omitempty"`
}

func (a *AccessRoleItemSelectors) GetMatch() map[string]string {
	if a == nil {
		return nil
	}
	return a.Match
}

type Sources struct {
	// Tags to match, can be used for both source and destinations
	Match map[string]string `json:"match,omitempty"`
}

func (s *Sources) GetMatch() map[string]string {
	if s == nil {
		return nil
	}
	return s.Match
}

type AccessRoleItemTargetRef struct {
	Kind *string           `json:"kind,omitempty"`
	Mesh *string           `json:"mesh,omitempty"`
	Name *string           `json:"name,omitempty"`
	Tags map[string]string `json:"tags,omitempty"`
}

func (a *AccessRoleItemTargetRef) GetKind() *string {
	if a == nil {
		return nil
	}
	return a.Kind
}

func (a *AccessRoleItemTargetRef) GetMesh() *string {
	if a == nil {
		return nil
	}
	return a.Mesh
}

func (a *AccessRoleItemTargetRef) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AccessRoleItemTargetRef) GetTags() map[string]string {
	if a == nil {
		return nil
	}
	return a.Tags
}

type AccessRoleItemRulesWhenTargetRef struct {
	Kind *string           `json:"kind,omitempty"`
	Mesh *string           `json:"mesh,omitempty"`
	Name *string           `json:"name,omitempty"`
	Tags map[string]string `json:"tags,omitempty"`
}

func (a *AccessRoleItemRulesWhenTargetRef) GetKind() *string {
	if a == nil {
		return nil
	}
	return a.Kind
}

func (a *AccessRoleItemRulesWhenTargetRef) GetMesh() *string {
	if a == nil {
		return nil
	}
	return a.Mesh
}

func (a *AccessRoleItemRulesWhenTargetRef) GetName() *string {
	if a == nil {
		return nil
	}
	return a.Name
}

func (a *AccessRoleItemRulesWhenTargetRef) GetTags() map[string]string {
	if a == nil {
		return nil
	}
	return a.Tags
}

type AccessRoleItemTo struct {
	TargetRef *AccessRoleItemRulesWhenTargetRef `json:"targetRef,omitempty"`
}

func (a *AccessRoleItemTo) GetTargetRef() *AccessRoleItemRulesWhenTargetRef {
	if a == nil {
		return nil
	}
	return a.TargetRef
}

type When struct {
	Destinations *Destinations            `json:"destinations,omitempty"`
	DpToken      *DpToken                 `json:"dpToken,omitempty"`
	From         *AccessRoleItemFrom      `json:"from,omitempty"`
	Selectors    *AccessRoleItemSelectors `json:"selectors,omitempty"`
	Sources      *Sources                 `json:"sources,omitempty"`
	TargetRef    *AccessRoleItemTargetRef `json:"targetRef,omitempty"`
	To           *AccessRoleItemTo        `json:"to,omitempty"`
}

func (w *When) GetDestinations() *Destinations {
	if w == nil {
		return nil
	}
	return w.Destinations
}

func (w *When) GetDpToken() *DpToken {
	if w == nil {
		return nil
	}
	return w.DpToken
}

func (w *When) GetFrom() *AccessRoleItemFrom {
	if w == nil {
		return nil
	}
	return w.From
}

func (w *When) GetSelectors() *AccessRoleItemSelectors {
	if w == nil {
		return nil
	}
	return w.Selectors
}

func (w *When) GetSources() *Sources {
	if w == nil {
		return nil
	}
	return w.Sources
}

func (w *When) GetTargetRef() *AccessRoleItemTargetRef {
	if w == nil {
		return nil
	}
	return w.TargetRef
}

func (w *When) GetTo() *AccessRoleItemTo {
	if w == nil {
		return nil
	}
	return w.To
}

type AccessRoleItemRules struct {
	Access []AccessRoleItemAccess `json:"access"`
	Mesh   *string                `json:"mesh,omitempty"`
	Names  []string               `json:"names"`
	Types  []string               `json:"types"`
	When   []When                 `json:"when"`
}

func (a *AccessRoleItemRules) GetAccess() []AccessRoleItemAccess {
	if a == nil {
		return nil
	}
	return a.Access
}

func (a *AccessRoleItemRules) GetMesh() *string {
	if a == nil {
		return nil
	}
	return a.Mesh
}

func (a *AccessRoleItemRules) GetNames() []string {
	if a == nil {
		return nil
	}
	return a.Names
}

func (a *AccessRoleItemRules) GetTypes() []string {
	if a == nil {
		return nil
	}
	return a.Types
}

func (a *AccessRoleItemRules) GetWhen() []When {
	if a == nil {
		return nil
	}
	return a.When
}

type AccessRoleItem struct {
	Labels map[string]string     `json:"labels,omitempty"`
	Name   string                `json:"name"`
	Rules  []AccessRoleItemRules `json:"rules"`
	Type   string                `json:"type"`
}

func (a *AccessRoleItem) GetLabels() map[string]string {
	if a == nil {
		return nil
	}
	return a.Labels
}

func (a *AccessRoleItem) GetName() string {
	if a == nil {
		return ""
	}
	return a.Name
}

func (a *AccessRoleItem) GetRules() []AccessRoleItemRules {
	if a == nil {
		return nil
	}
	return a.Rules
}

func (a *AccessRoleItem) GetType() string {
	if a == nil {
		return ""
	}
	return a.Type
}
